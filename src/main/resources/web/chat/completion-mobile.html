<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Easy Chat Mobile</title>
  <style>
    :root {
      --bg: #f9fafb;
      --panel: rgba(255, 255, 255, 0.92);
      --panel-2: rgba(243, 244, 246, 0.92);
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e5e7eb;
      --primary: #10a37f;
      --danger: #ef4444;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
      --bubble-user: #eff6ff;
      --bubble-ai: #f0fdf4;
      --bubble-sys: #f3f4f6;
      --input-bg: #ffffff;
      --surface: #ffffff;
      --surface-2: #f9fafb;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      color: var(--text);
      font-family: var(--sans);
      background:
        radial-gradient(1000px 700px at 15% 10%, rgba(16, 163, 127, 0.05), transparent 55%),
        radial-gradient(900px 650px at 85% 5%, rgba(59, 130, 246, 0.05), transparent 55%),
        radial-gradient(800px 600px at 55% 95%, rgba(168, 85, 247, 0.04), transparent 55%),
        var(--bg);
      overflow: hidden;
    }

    button,
    input,
    select,
    textarea {
      font-family: inherit;
      color: var(--text);
    }

    .app {
      height: 100dvh;
      display: flex;
      flex-direction: column;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel-2);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .title-input {
      flex: 1;
      min-width: 0;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
      height: 38px;
    }

    .btn {
      border: 1px solid var(--border);
      background: var(--surface);
      border-radius: 12px;
      padding: 8px 12px;
      cursor: pointer;
      transition: transform 0.06s ease, background 0.16s ease, border-color 0.16s ease;
      min-height: 38px;
      font-size: 14px;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .btn.primary {
      border-color: rgba(16, 163, 127, 0.5);
      background: rgba(16, 163, 127, 0.18);
    }

    .btn.danger {
      border-color: rgba(239, 68, 68, 0.5);
      background: rgba(239, 68, 68, 0.16);
    }

    .btn.ghost {
      background: transparent;
    }

    .icon-btn {
      width: 38px;
      height: 38px;
      padding: 0;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      font-size: 18px;
    }

    .chat-list {
      flex: 1;
      overflow: auto;
      padding: 12px 12px 190px;
      background:
        radial-gradient(700px 450px at 40% 10%, rgba(148, 163, 184, 0.08), transparent 65%),
        transparent;
    }

    #chatList {
      scrollbar-color: rgba(148, 163, 184, 0.35) rgba(0, 0, 0, 0.05);
      scrollbar-width: thin;
    }

    #chatList::-webkit-scrollbar {
      width: 8px;
    }

    #chatList::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 999px;
    }

    #chatList::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.45), rgba(16, 163, 127, 0.22));
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.55);
    }

    #chatList::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.6), rgba(16, 163, 127, 0.32));
    }

    .msg {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 0;
      padding: 10px 0;
      align-items: stretch;
      border-bottom: 1px solid var(--border);
    }

    .msg-head {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: linear-gradient(180deg, #ffffff, #f9fafb);
    }

    .msg.user .msg-head {
      border-color: #bfdbfe;
      background: linear-gradient(180deg, #eff6ff, #f9fafb);
    }

    .msg.assistant .msg-head {
      border-color: #bbf7d0;
      background: linear-gradient(180deg, #f0fdf4, #f9fafb);
    }

    .msg.system .msg-head {
      border-color: #e2e8f0;
      background: linear-gradient(180deg, #f1f5f9, #f9fafb);
    }

    .msg.tool .msg-head {
      border-color: #fed7aa;
      background: linear-gradient(180deg, #fff7ed, #f9fafb);
    }

    .msg-head .meta {
      flex: 1 1 auto;
      min-width: 0;
    }

    .avatar {
      width: 32px;
      height: 32px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--surface);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: var(--muted);
      flex: 0 0 auto;
      user-select: none;
    }
    
    .avatar.clickable {
      cursor: pointer;
    }
    
    .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
      display: block;
    }
    
    .avatar-setting .avatar {
      width: 42px;
      height: 42px;
    }
    
    .avatar-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .bubble {
      width: 100%;
      flex: 0 0 auto;
      min-width: 0;
      max-width: 100%;
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
      overflow: visible;
    }

    .msg.user .bubble,
    .msg.assistant .bubble,
    .msg.system .bubble {
      border-radius: 12px;
      padding: 10px 12px;
    }

    .msg.user .bubble {
      background: linear-gradient(135deg, #eff6ff, #f9fafb 70%);
      border: 1px solid #bfdbfe;
    }

    .msg.assistant .bubble {
      background: linear-gradient(135deg, #f0fdf4, #f9fafb 70%);
      border: 1px solid #bbf7d0;
    }

    .msg.system .bubble {
      background: linear-gradient(135deg, #f1f5f9, #f9fafb 70%);
      border: 1px solid #e2e8f0;
    }

    .msg.tool .bubble {
      border-radius: 12px;
      padding: 10px 12px;
      background: linear-gradient(135deg, #fff7ed, #f9fafb 70%);
      border: 1px solid #fed7aa;
    }

    .meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 0;
      color: var(--muted);
      font-size: 12px;
    }

    .meta-left {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1 1 auto;
    }

    .meta-right {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      min-width: 0;
      flex: 0 0 auto;
    }

    .content {
      white-space: normal;
      word-break: break-word;
      line-height: 1.55;
      font-size: 14px;
      text-align: left;
    }

    .token-info {
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
      text-align: left;
      user-select: text;
      white-space: pre-wrap;
    }

    .content.plain {
      white-space: pre-wrap;
    }

    .content p {
      margin: 0 0 10px 0;
    }

    .content p:last-child {
      margin-bottom: 0;
    }

    .content ul,
    .content ol {
      margin: 6px 0 10px 1.25em;
      padding: 0;
    }

    .content li {
      margin: 2px 0;
    }

    .content blockquote {
      margin: 8px 0;
      padding: 6px 12px;
      border-left: 3px solid var(--border);
      border-radius: 10px;
      background: var(--surface-2);
      color: var(--muted);
    }

    .content pre {
      margin: 8px 0;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #f1f5f9;
      overflow-x: auto;
    }

    .content code {
      font-family: var(--mono);
      font-size: 0.95em;
    }

    .content :not(pre)>code {
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #f1f5f9;
    }

    .content a {
      color: #2563eb;
      text-decoration: underline;
      word-break: break-word;
    }

    .content table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 13px;
    }

    .content th,
    .content td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }

    .content hr {
      border: 0;
      border-top: 1px solid var(--border);
      margin: 10px 0;
    }

    .content img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .composer {
      position: sticky;
      bottom: 0;
      background: var(--panel);
      border-top: 1px solid var(--border);
      padding: 10px 12px calc(12px + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
      gap: 8px;
      backdrop-filter: blur(14px);
      z-index: 8;
    }

    .model-row {
      display: none;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .model-row.visible {
      display: flex;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      font-size: 11px;
      white-space: nowrap;
      min-height: 28px;
    }

    .pill input {
      margin: 0;
    }

    .model-row .pill {
      flex: 1 1 100%;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .model-row .pill select {
      flex: 1;
      min-width: 0;
    }

    #modelSelect {
      background: var(--input-bg);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface-2);
      font-size: 11px;
    }

    .toggle input {
      margin: 0;
    }

    .prompt-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }

    .prompt-row textarea {
      flex: 1;
      min-height: 44px;
      max-height: 140px;
      resize: none;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      line-height: 1.5;
    }

    .prompt-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    #saveHint {
      font-size: 11px;
    }

    .attach-info {
      display: none;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 6px 8px;
      background: var(--surface-2);
    }

    .attach-info .clear {
      width: 26px;
      height: 26px;
      border-radius: 10px;
      min-height: 26px;
      padding: 0;
    }

    .attach-info.active {
      display: flex;
    }

    .attach-info .name {
      color: var(--text);
      max-width: 60vw;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .spacer {
      flex: 1;
    }

    .backdrop,
    .settings-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 30;
    }

    .backdrop.show,
    .settings-backdrop.show {
      opacity: 1;
      pointer-events: auto;
    }

    .drawer {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: min(86vw, 340px);
      background: rgba(255, 255, 255, 0.96);
      border-left: 1px solid var(--border);
      transform: translateX(100%);
      transition: transform 0.22s ease;
      z-index: 40;
      display: flex;
      flex-direction: column;
    }

    .drawer.open {
      transform: translateX(0);
    }

    .drawer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
    }

    .drawer-title {
      font-weight: 700;
    }

    .drawer-actions {
      padding: 12px 14px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      border-bottom: 1px solid var(--border);
    }

    .sessions {
      list-style: none;
      margin: 0;
      padding: 10px 12px;
      overflow: auto;
      flex: 1;
    }

    .session-item {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      background: var(--surface);
    }

    .session-meta {
      flex: 1;
      min-width: 0;
    }

    .session-title {
      font-weight: 700;
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .session-sub {
      font-size: 12px;
      color: var(--muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 4px;
    }

    .settings {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      transform: translateY(100%);
      transition: transform 0.22s ease;
      z-index: 60;
      background: rgba(255, 255, 255, 0.98);
      border-top: 1px solid var(--border);
      border-radius: 18px 18px 0 0;
      max-height: min(88dvh, 780px);
      display: flex;
      flex-direction: column;
    }

    .settings.open {
      transform: translateY(0);
    }

    .settings-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: var(--surface-2);
    }

    .settings-title {
      font-weight: 700;
    }

    .settings-body {
      padding: 12px 14px calc(16px + env(safe-area-inset-bottom));
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .setting {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .setting label {
      font-size: 12px;
      color: var(--muted);
    }

    .setting input,
    .setting select,
    .setting textarea {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
      font-size: 14px;
    }

    .setting textarea {
      min-height: 88px;
      resize: vertical;
      line-height: 1.5;
    }

    .long-setting textarea {
      min-height: 96px;
    }

    .mcp-tools-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .mcp-tools-actions .hint {
      flex: 1 1 auto;
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mcp-tools {
      max-height: 40vh;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      background: var(--surface-2);
    }

    .mcp-server {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface);
      overflow: hidden;
    }

    .mcp-server + .mcp-server {
      margin-top: 8px;
    }

    .mcp-server-summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }
    
    .mcp-server-summary::-webkit-details-marker {
      display: none;
    }

    .mcp-server-title {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
      font-weight: 800;
      font-size: 13.5px;
    }

    .mcp-server-badge {
      flex: 0 0 auto;
      font-size: 11px;
      line-height: 1.5;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f1f5f9;
      color: var(--muted);
    }

    .mcp-server-body {
      border-top: 1px solid var(--border);
      padding: 10px 12px;
    }

    .mcp-server-url {
      color: var(--muted);
      font-size: 12px;
      word-break: break-all;
    }

    .mcp-tool-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }

    .mcp-tool-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface-2);
      cursor: pointer;
      user-select: none;
    }
    
    .mcp-tool-row:active {
      transform: translateY(1px);
    }

    .mcp-tool-label {
      min-width: 0;
      font-size: 13px;
      font-weight: 650;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .mcp-tool-toggle {
      -webkit-appearance: none;
      appearance: none;
      width: 42px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid #94a3b8;
      background: #cbd5e1;
      position: relative;
      cursor: pointer;
      flex: 0 0 auto;
      transition: background 0.16s ease, border-color 0.16s ease;
    }
    
    .mcp-tool-toggle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 3px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: #ffffff;
      border: 1px solid rgba(15, 23, 42, 0.12);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.18);
      transform: translateY(-50%);
      transition: transform 0.16s ease;
    }

    .mcp-tool-toggle:checked {
      background: #10a37f;
      border-color: #0f8a6b;
    }
    
    .mcp-tool-toggle:checked::before {
      transform: translate(18px, -50%);
    }

    .mcp-tool-toggle:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px rgba(16, 163, 127, 0.18);
    }

    .sys-prompt {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface-2);
      padding: 10px 12px;
    }

    .sys-prompt textarea {
      width: 100%;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
      font-size: 14px;
      min-height: 96px;
      resize: vertical;
      line-height: 1.5;
    }

    .sys-title {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .section-title {
      font-weight: 700;
      margin-top: 6px;
    }

    .msg-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    .msg-btn {
      border: 1px solid var(--border);
      background: var(--surface);
      border-radius: 10px;
      padding: 4px 8px;
      cursor: pointer;
      transition: transform 0.06s ease, background 0.16s ease, border-color 0.16s ease;
      min-height: 24px;
      font-size: 12px;
      line-height: 1.1;
      color: var(--text);
    }

    .msg-btn:active {
      transform: translateY(1px);
    }

    .msg-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .msg-btn.ghost {
      background: transparent;
    }

    .msg-btn.danger {
      border-color: rgba(239, 68, 68, 0.55);
      background: rgba(239, 68, 68, 0.16);
    }

    .attachments {
      margin-top: 10px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .attachment-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      background: var(--surface);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .attachment-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .attachment-name {
      font-size: 13px;
      color: var(--text);
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .attachment-link {
      color: var(--primary);
      text-decoration: none;
      font-size: 13px;
      flex: 0 0 auto;
    }

    .attachment-preview {
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: var(--surface-2);
      overflow: hidden;
    }

    .attachment-preview img {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .attachment-preview pre {
      margin: 0;
      padding: 10px 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12.5px;
      line-height: 1.5;
      color: var(--text);
    }

    .reasoning {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #f8fafc;
      padding: 6px 10px;
      margin: 8px 0;
      font-size: 12px;
    }

    .reasoning summary {
      cursor: pointer;
      color: var(--muted);
    }

    .reasoning pre {
      margin: 8px 0 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12px;
    }

    .tool-result {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff7ed;
      padding: 6px 10px;
      margin: 8px 0;
      font-size: 12px;
    }

    .tool-result summary {
      cursor: pointer;
      color: var(--muted);
    }

    .modal-wrap {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
      background: rgba(0, 0, 0, 0.55);
      z-index: 80;
    }

    .modal-wrap.show {
      display: flex;
    }

    .modal-card {
      width: min(760px, calc(100vw - 28px));
      max-height: calc(100vh - 28px);
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: var(--surface-2);
    }

    .modal-title {
      font-weight: 800;
    }

    .modal-body {
      padding: 12px 14px;
      overflow: auto;
    }

    .modal-body textarea {
      width: 100%;
      resize: vertical;
      min-height: 180px;
      max-height: 52vh;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      outline: none;
      line-height: 1.5;
      font-size: 14px;
    }

    .modal-actions {
      padding: 12px 14px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      background: var(--surface-2);
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <input id="titleInput" class="title-input" type="text" placeholder="ËßíËâ≤ÂêçÁß∞ÔºàËá™Âä®‰øùÂ≠òÔºâ" />
      <button id="sessionsToggle" class="btn icon-btn ghost" type="button" aria-label="ËßíËâ≤ÂàóË°®">‚ò∞</button>
      <button id="toggleSettings" class="btn icon-btn ghost" type="button" aria-label="ËÆæÁΩÆ">‚öô</button>
    </div>

    <div id="chatList" class="chat-list"></div>

    <div class="composer">
      <div class="model-row">
        <div class="pill">
          <label for="modelSelect">Ê®°Âûã</label>
          <select id="modelSelect"></select>
          <button id="refreshModels" class="btn" type="button">Âà∑Êñ∞</button>
        </div>
        <div class="toggle">
          <input id="autoScroll" type="checkbox" checked />
          <label for="autoScroll" class="hint">Ëá™Âä®ÊªöÂä®</label>
        </div>
        <div class="toggle">
          <input id="streamToggle" type="checkbox" checked />
          <label for="streamToggle" class="hint">ÊµÅÂºè‰º†Ëæì</label>
        </div>
        <div class="toggle">
          <input id="thinkingToggle" type="checkbox" checked />
          <label for="thinkingToggle" class="hint">ÂºÄÂêØÊÄùËÄÉ</label>
        </div>
        <div class="toggle">
          <input id="webSearchToggle" type="checkbox" />
          <label for="webSearchToggle" class="hint">ËÅîÁΩëÊêúÁ¥¢</label>
        </div>
        <button id="clearChat" class="btn" type="button">Ê∏ÖÁ©∫</button>
        <button id="kvCacheToggle" class="btn icon-btn ghost" type="button" title="KVÁºìÂ≠òÁÆ°ÁêÜ">üíæ</button>
      </div>

      <div id="settingsPanel" class="settings">
        <div class="settings-head">
          <div class="settings-title">Ê®°Âûã‰∏éËÆæÁΩÆ</div>
          <button id="closeSettings" class="btn icon-btn" type="button" aria-label="ÂÖ≥Èó≠">√ó</button>
        </div>
        <div class="settings-body">
          <div class="section-title" id="modelSection">Ê†∏ÂøÉÂèÇÊï∞</div>
          <div class="setting avatar-setting">
            <label>Â§¥ÂÉè</label>
            <div class="avatar-row">
              <div id="avatarSettingPreview" class="avatar clickable" title="ÁÇπÂáªÊü•ÁúãÂ§¥ÂÉè">AI</div>
              <button id="avatarSettingUpload" class="btn" type="button">Êõ¥Êç¢</button>
            </div>
          </div>
          <div class="setting">
            <label for="apiModelSelect">API Á´ØÁÇπ</label>
            <select id="apiModelSelect">
              <option value="1">/v1/chat/completions</option>
              <option value="0">/v1/completions</option>
            </select>
          </div>
          <div class="setting">
            <label for="userName">Áî®Êà∑ÂêçÂ≠ó</label>
            <input id="userName" type="text" placeholder="‰æãÂ¶ÇÔºöÊàë" />
          </div>
          <div class="setting">
            <label for="maxTokens">max_tokens</label>
            <input id="maxTokens" type="number" value="512" min="1" max="32768" />
          </div>
          <div class="setting">
            <label for="temperature">temperature</label>
            <input id="temperature" type="number" value="0.7" step="0.1" min="0" max="2" />
          </div>
          <div class="setting">
            <label for="topP">top_p</label>
            <input id="topP" type="number" value="1" step="0.05" min="0" max="1" />
          </div>
          <div class="setting">
            <label for="minP">min_p</label>
            <input id="minP" type="number" step="0.01" min="0" max="1" value="0.05" />
          </div>
          <div class="setting">
            <label for="repeatPenalty">repeat_penalty</label>
            <input id="repeatPenalty" type="number" step="0.05" min="0" max="10" value="1.0" />
          </div>
          <div class="setting">
            <label for="stopSequences">stop</label>
            <textarea id="stopSequences" placeholder="‰∏ÄË°å‰∏Ä‰∏™ stop Â∫èÂàó"></textarea>
          </div>

          <div id="sysPromptBox" class="sys-prompt">
            <div class="sys-title">Á≥ªÁªüÊèèËø∞</div>
            <textarea id="systemPrompt" placeholder="Â∞ÜÂä†ÂÖ•Âà∞ÂØπËØùÂºÄÂ§¥"></textarea>
          </div>
          <div id="rolePromptBox" class="sys-prompt">
            <div class="sys-title">ËßíËâ≤ËÆæÂÆö</div>
            <textarea id="rolePrompt" placeholder="Â∞ÜÂä†ÂÖ•Âà∞ÂØπËØùÂºÄÂ§¥"></textarea>
          </div>

          <div class="setting long-setting">
            <label for="userPrefix">Áî®Êà∑Ê∂àÊÅØÂâçÁºÄ</label>
            <textarea id="userPrefix" placeholder="ÂèØÈÄâ"></textarea>
          </div>
          <div class="setting long-setting">
            <label for="userSuffix">Áî®Êà∑Ê∂àÊÅØÂêéÁºÄ</label>
            <textarea id="userSuffix" placeholder="ÂèØÈÄâ"></textarea>
          </div>
          <div class="setting long-setting">
            <label for="assistantPrefix">Âä©ÊâãÊ∂àÊÅØÂâçÁºÄ</label>
            <textarea id="assistantPrefix" placeholder="ÂèØÈÄâ"></textarea>
          </div>
          <div class="setting long-setting">
            <label for="assistantSuffix">Âä©ÊâãÊ∂àÊÅØÂêéÁºÄ</label>
            <textarea id="assistantSuffix" placeholder="ÂèØÈÄâ"></textarea>
          </div>
          <div class="setting long-setting">
            <label>MCP Â∑•ÂÖ∑</label>
            <div class="mcp-tools-actions">
              <button id="refreshMcpTools" class="btn" type="button">Âà∑Êñ∞</button>
              <span id="mcpToolsStatus" class="hint"></span>
            </div>
            <div id="mcpToolsList" class="mcp-tools"></div>
          </div>
        </div>
      </div>

      <div class="prompt-row">
      	<div class="prompt-actions">
      		<button id="attachBtn" class="btn" type="button">ÈôÑ‰ª∂</button>
        	<button id="modelRowToggle" style="width: 100%; height: 100%" class="btn icon-btn ghost" type="button" title="ÊòæÁ§∫Ê®°ÂûãÊ†è" aria-label="ÊòæÁ§∫Ê®°ÂûãÊ†è" aria-expanded="false">‚ò∞</button>
        </div>
        <textarea id="promptInput" placeholder="ËæìÂÖ•Ê∂àÊÅØ‚Ä¶ÔºàCtrl+Enter ÂèëÈÄÅÔºâ"></textarea>
        <div class="prompt-actions">
          <button id="sendBtn" class="btn primary" type="button">ÂèëÈÄÅ</button>
          <button id="stopBtn" class="btn danger" type="button" disabled>ÂÅúÊ≠¢</button>
        </div>
        <input id="attachInput" type="file" style="display:none" />
      </div>
      <div class="toolbar">
        <div class="hint" id="saveHint"></div>
        <div id="attachInfo" class="attach-info" aria-live="polite">
          <span class="hint">Â∑≤ÈÄâÈôÑ‰ª∂</span>
          <span id="attachName" class="name"></span>
          <button id="attachClear" class="btn icon-btn clear" type="button" aria-label="Ê∏ÖÈô§ÈôÑ‰ª∂">√ó</button>
        </div>
        <div class="spacer"></div>
      </div>
    </div>

    <div id="drawerBackdrop" class="backdrop"></div>
    <aside id="sessionsDrawer" class="drawer" aria-hidden="true">
      <div class="drawer-header">
        <div class="drawer-title">ËßíËâ≤</div>
        <button id="drawerClose" class="btn icon-btn" type="button" aria-label="ÂÖ≥Èó≠">√ó</button>
      </div>
      <div class="drawer-actions">
        <button id="newSessionBtn" class="btn primary" type="button">Êñ∞Âª∫ËßíËâ≤</button>
        <button id="reloadSessionsBtn" class="btn" type="button">Âà∑Êñ∞</button>
        <span class="hint" id="drawerHint"></span>
      </div>
      <ul id="sessionsList" class="sessions">
        <li class="session-item">
          <div class="session-meta">
            <div class="session-title">ÈªòËÆ§ËßíËâ≤</div>
            <div class="session-sub">‰∏äÊ¨°Êõ¥Êñ∞ÔºöÂàöÂàö</div>
          </div>
          <button class="btn icon-btn ghost" type="button">‚ãØ</button>
        </li>
      </ul>
    </aside>

    <div id="editModal" class="modal-wrap" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="modal-title">ÁºñËæëÊ∞îÊ≥°</div>
          <button id="editClose" class="btn icon-btn" type="button" aria-label="ÂÖ≥Èó≠">√ó</button>
        </div>
        <div class="modal-body">
          <textarea id="editTextarea" placeholder="ËæìÂÖ•Êñ∞ÁöÑÂÜÖÂÆπ‚Ä¶"></textarea>
        </div>
        <div class="modal-actions">
          <button id="editCancel" class="btn" type="button">ÂèñÊ∂à</button>
          <button id="editSave" class="btn primary" type="button">‰øùÂ≠ò</button>
        </div>
      </div>
    </div>

    <div id="kvCacheModal" class="modal-wrap" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="modal-title">KVÁºìÂ≠òÁÆ°ÁêÜ</div>
          <button id="kvCacheClose" class="btn icon-btn" type="button" aria-label="ÂÖ≥Èó≠">√ó</button>
        </div>
        <div class="modal-body">
          <p style="color: var(--muted); font-size: 14px; margin: 0 0 16px 0;">ÁÆ°ÁêÜÂΩìÂâçÊ®°ÂûãÁöÑKVÁºìÂ≠òÔºåÂèØ‰ª•‰øùÂ≠òÊàñÂä†ËΩΩÁºìÂ≠ò‰ª•Âä†Âø´Êé®ÁêÜÈÄüÂ∫¶„ÄÇ</p>
          <div style="display: flex; gap: 12px; justify-content: center;">
            <button id="saveKV" class="btn" type="button" style="min-width: 120px;">‰øùÂ≠òKVÁºìÂ≠ò</button>
            <button id="loadKV" class="btn" type="button" style="min-width: 120px;">Âä†ËΩΩKVÁºìÂ≠ò</button>
          </div>
        </div>
        <div class="modal-actions">
          <button id="kvCacheCancel" class="btn" type="button">ÂÖ≥Èó≠</button>
        </div>
      </div>
    </div>
  </div>

  <script src="/js/lz-string.js"></script>
  <script src="/js/marked.min.js"></script>
  <script src="/js/highlight.min.js"></script>
  <script>
    const els = {
      sessionsToggle: document.getElementById('sessionsToggle'),
      drawer: document.getElementById('sessionsDrawer'),
      backdrop: document.getElementById('drawerBackdrop'),
      drawerClose: document.getElementById('drawerClose'),
      sessionsList: document.getElementById('sessionsList'),
      newSessionBtn: document.getElementById('newSessionBtn'),
      reloadSessionsBtn: document.getElementById('reloadSessionsBtn'),
      drawerHint: document.getElementById('drawerHint'),

      titleInput: document.getElementById('titleInput'),
      chatList: document.getElementById('chatList'),
      promptInput: document.getElementById('promptInput'),
      modelRowToggle: document.getElementById('modelRowToggle'),
      modelRow: document.querySelector('.model-row'),

      modelSelect: document.getElementById('modelSelect'),
      refreshModels: document.getElementById('refreshModels'),

      attachBtn: document.getElementById('attachBtn'),
      attachInput: document.getElementById('attachInput'),
      attachInfo: document.getElementById('attachInfo'),
      attachName: document.getElementById('attachName'),
      attachClear: document.getElementById('attachClear'),

      sendBtn: document.getElementById('sendBtn'),
      stopBtn: document.getElementById('stopBtn'),
      clearChat: document.getElementById('clearChat'),

      toggleSettings: document.getElementById('toggleSettings'),
      settingsPanel: document.getElementById('settingsPanel'),
      closeSettings: document.getElementById('closeSettings'),
      sysPromptBox: document.getElementById('sysPromptBox'),
      systemPrompt: document.getElementById('systemPrompt'),
      rolePromptBox: document.getElementById('rolePromptBox'),
      rolePrompt: document.getElementById('rolePrompt'),
      refreshMcpTools: document.getElementById('refreshMcpTools'),
      mcpToolsStatus: document.getElementById('mcpToolsStatus'),
      mcpToolsList: document.getElementById('mcpToolsList'),

      maxTokens: document.getElementById('maxTokens'),
      temperature: document.getElementById('temperature'),
      topP: document.getElementById('topP'),
      minP: document.getElementById('minP'),
      repeatPenalty: document.getElementById('repeatPenalty'),
      stopSequences: document.getElementById('stopSequences'),
      userName: document.getElementById('userName'),
      userPrefix: document.getElementById('userPrefix'),
      userSuffix: document.getElementById('userSuffix'),
      assistantPrefix: document.getElementById('assistantPrefix'),
      assistantSuffix: document.getElementById('assistantSuffix'),
      apiModelSelect: document.getElementById('apiModelSelect'),
      avatarSettingPreview: document.getElementById('avatarSettingPreview'),
      avatarSettingUpload: document.getElementById('avatarSettingUpload'),

      autoScroll: document.getElementById('autoScroll'),
      streamToggle: document.getElementById('streamToggle'),
      thinkingToggle: document.getElementById('thinkingToggle'),
      webSearchToggle: document.getElementById('webSearchToggle'),
      saveHint: document.getElementById('saveHint'),

      kvCacheToggle: document.getElementById('kvCacheToggle'),
      kvCacheModal: document.getElementById('kvCacheModal'),
      kvCacheClose: document.getElementById('kvCacheClose'),
      kvCacheCancel: document.getElementById('kvCacheCancel'),
      saveKV: document.getElementById('saveKV'),
      loadKV: document.getElementById('loadKV'),

      editModal: document.getElementById('editModal'),
      editTextarea: document.getElementById('editTextarea'),
      editClose: document.getElementById('editClose'),
      editCancel: document.getElementById('editCancel'),
      editSave: document.getElementById('editSave')
    };

    const state = {
      currentCompletionId: null,
      currentCreatedAt: 0,
      isLoadingCompletions: false,
      isLoadingModels: false,
      abortController: null,
      saveTimer: null,
      lastSavedAt: 0,
      statusText: '',
      saveHintText: '',
      messages: [],
      systemLogs: [],
      timingsLog: [],
      messageEls: new Map(),
      editingMessageId: null,
      msgSeq: 0,
      apiModel: 1,
      pendingAttachment: null,
      avatarNonce: 0,
      mcpToolsData: null,
      enabledMcpTools: []
    };

    function uid() {
      if (window.crypto?.randomUUID) return crypto.randomUUID();
      return String(Date.now()) + '-' + String(Math.random()).slice(2);
    }

    function nextMessageOrder() {
      state.msgSeq = (Number.isFinite(state.msgSeq) ? state.msgSeq : 0) + 1;
      return state.msgSeq;
    }

    function escapeHtml(text) {
      return String(text == null ? '' : text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function isSafeUrl(value) {
      const href = String(value == null ? '' : value).trim();
      if (!href) return false;
      if (href.startsWith('#')) return true;
      try {
        const u = new URL(href, window.location.href);
        const p = u.protocol;
        return p === 'http:' || p === 'https:' || p === 'mailto:' || p === 'tel:';
      } catch (e) {
        return false;
      }
    }

    function sanitizeMarkdownHtml(html) {
      const allowedTags = new Set([
        'div',
        'p', 'br', 'strong', 'em', 'del',
        'code', 'pre',
        'blockquote',
        'ul', 'ol', 'li',
        'a', 'hr',
        'table', 'thead', 'tbody', 'tr', 'th', 'td',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'img', 'span'
      ]);

      const allowedAttrsByTag = {
        a: new Set(['href', 'title', 'target', 'rel']),
        img: new Set(['src', 'alt', 'title']),
        th: new Set(['align']),
        td: new Set(['align']),
        code: new Set(['class']),
        pre: new Set(['class']),
        span: new Set(['class'])
      };

      const doc = new DOMParser().parseFromString('<div>' + String(html || '') + '</div>', 'text/html');
      const root = doc.body && doc.body.firstChild ? doc.body.firstChild : null;
      if (!root) return '';

      const walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null);
      const nodes = [];
      let n = walker.currentNode;
      while (n) {
        nodes.push(n);
        n = walker.nextNode();
      }

      for (const el of nodes) {
        const tag = (el.tagName || '').toLowerCase();
        if (!allowedTags.has(tag)) {
          const parent = el.parentNode;
          if (!parent) continue;
          while (el.firstChild) parent.insertBefore(el.firstChild, el);
          parent.removeChild(el);
          continue;
        }

        const allowedAttrs = allowedAttrsByTag[tag] || null;
        for (const attr of Array.from(el.attributes || [])) {
          const name = (attr.name || '').toLowerCase();
          if (!allowedAttrs || !allowedAttrs.has(name)) {
            el.removeAttribute(attr.name);
            continue;
          }
          if ((tag === 'a' && name === 'href') || (tag === 'img' && name === 'src')) {
            const v = el.getAttribute(attr.name) || '';
            if (!isSafeUrl(v)) el.removeAttribute(attr.name);
          }
        }

        if (tag === 'a') {
          el.setAttribute('rel', 'noopener noreferrer');
          if (!el.getAttribute('target')) el.setAttribute('target', '_blank');
        }
      }

      return root.innerHTML;
    }

    function markdownToSafeHtml(text) {
      const input = escapeHtml(text);
      if (!window.marked || typeof window.marked.parse !== 'function') return input;
      let raw = '';
      try {
        raw = window.marked.parse(input, { gfm: true, breaks: true, mangle: false, headerIds: false });
      } catch (e) {
        return input;
      }
      return sanitizeMarkdownHtml(raw);
    }

    let markdownRaf = 0;
    const pendingMarkdownRenders = new Map();

    function renderMessageContentNow(el, text) {
      if (!el) return;
      const t = (text == null ? '' : String(text));
      if (!window.marked || typeof window.marked.parse !== 'function') {
        el.classList.add('plain');
        el.textContent = t;
        return;
      }
      el.classList.remove('plain');
      el.innerHTML = markdownToSafeHtml(t);
      if (window.hljs && typeof window.hljs.highlightElement === 'function' && (t.includes('```') || t.includes('`'))) {
        const blocks = el.querySelectorAll('pre code');
        for (const b of blocks) window.hljs.highlightElement(b);
      }
    }

    function requestRenderMessageContent(el, text) {
      if (!el) return;
      pendingMarkdownRenders.set(el, text);
      if (markdownRaf) return;
      markdownRaf = requestAnimationFrame(() => {
        markdownRaf = 0;
        for (const [node, value] of pendingMarkdownRenders.entries()) {
          renderMessageContentNow(node, value);
        }
        pendingMarkdownRenders.clear();
      });
    }

    function refreshHintUi() {
      const statusText = state.statusText ? String(state.statusText) : '';
      const saveText = state.saveHintText ? String(state.saveHintText) : '';
      const merged = statusText ? (saveText ? (statusText + ' ¬∑ ' + saveText) : statusText) : saveText;
      if (els.saveHint) els.saveHint.textContent = merged;
    }

    function setStatus(text) {
      state.statusText = (text == null ? '' : String(text));
      refreshHintUi();
    }

    function setSaveHint(text) {
      state.saveHintText = (text == null ? '' : String(text));
      refreshHintUi();
    }

    async function fetchJson(url, options) {
      const res = await fetch(url, options);
      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch (e) { }
      if (!res.ok) {
        const message = (json && (json.message || json.error?.message)) ? (json.message || json.error.message) : (text || ('HTTP ' + res.status));
        throw new Error(message);
      }
      return json;
    }

    let mcpToolsLoading = false;
    function normalizeToolName(name) {
      return (name == null ? '' : String(name)).trim();
    }

    function isMcpToolEnabled(toolName) {
      const tn = normalizeToolName(toolName);
      if (!tn) return false;
      const list = Array.isArray(state.enabledMcpTools) ? state.enabledMcpTools : [];
      return list.includes(tn);
    }

    function setMcpToolEnabled(toolName, enabled) {
      const tn = normalizeToolName(toolName);
      if (!tn) return;
      const list = Array.isArray(state.enabledMcpTools) ? state.enabledMcpTools.slice() : [];
      const has = list.includes(tn);
      if (enabled && !has) list.push(tn);
      if (!enabled && has) {
        const idx = list.indexOf(tn);
        if (idx >= 0) list.splice(idx, 1);
      }
      state.enabledMcpTools = list;
    }

    function updateMcpToolsStatus() {
      const data = state.mcpToolsData || {};
      const servers = data?.servers;
      const serverCount = (servers && typeof servers === 'object') ? Object.keys(servers).length : 0;
      const enabledCount = Array.isArray(state.enabledMcpTools) ? state.enabledMcpTools.length : 0;
      if (els.mcpToolsStatus) {
        if (!serverCount) els.mcpToolsStatus.textContent = 'ÊöÇÊó†ÊúçÂä°';
        else els.mcpToolsStatus.textContent = `ÊúçÂä°Êï∞Ôºö${serverCount} ¬∑ Â∑≤ÂêØÁî®Ôºö${enabledCount}`;
      }
    }

    function renderMcpTools(data) {
      state.mcpToolsData = (data && typeof data === 'object') ? data : null;
      const wrap = els.mcpToolsList;
      if (!wrap) return;
      wrap.textContent = '';
      const servers = data?.servers;
      const entries = (servers && typeof servers === 'object') ? Object.entries(servers) : [];
      if (!entries.length) {
        wrap.textContent = 'ÊöÇÊó† MCP Â∑•ÂÖ∑';
        updateMcpToolsStatus();
        return;
      }

      for (const [url, server] of entries) {
        const serverObj = (server && typeof server === 'object') ? server : {};
        const serverName = (typeof serverObj.name === 'string' && serverObj.name.trim()) ? serverObj.name.trim() : '';
        const tools = Array.isArray(serverObj.tools) ? serverObj.tools : [];

        const serverEl = document.createElement('details');
        serverEl.className = 'mcp-server';
        serverEl.open = true;

        const toolSeen = new Set();
        let totalTools = 0;
        let enabledTools = 0;
        for (const t of tools) {
          const toolObj = (t && typeof t === 'object') ? t : {};
          const tn0 = (typeof toolObj.name === 'string' && toolObj.name.trim()) ? toolObj.name.trim() : '';
          if (!tn0) continue;
          if (toolSeen.has(tn0)) continue;
          toolSeen.add(tn0);
          totalTools++;
          if (isMcpToolEnabled(tn0)) enabledTools++;
        }

        const summary = document.createElement('summary');
        summary.className = 'mcp-server-summary';

        const titleWrap = document.createElement('div');
        titleWrap.className = 'mcp-server-title';
        titleWrap.textContent = serverName ? `${serverName}` : `MCP`;

        const badge = document.createElement('div');
        badge.className = 'mcp-server-badge';
        badge.textContent = `${enabledTools}/${totalTools}`;

        summary.appendChild(titleWrap);
        summary.appendChild(badge);
        serverEl.appendChild(summary);

        const body = document.createElement('div');
        body.className = 'mcp-server-body';

        const urlEl = document.createElement('div');
        urlEl.className = 'mcp-server-url';
        urlEl.textContent = String(url || '');
        body.appendChild(urlEl);

        const list = document.createElement('div');
        list.className = 'mcp-tool-list';
        toolSeen.clear();
        for (const t of tools) {
          const toolObj = (t && typeof t === 'object') ? t : {};
          const tn = (typeof toolObj.name === 'string' && toolObj.name.trim()) ? toolObj.name.trim() : '';
          if (!tn) continue;
          if (toolSeen.has(tn)) continue;
          toolSeen.add(tn);
          const row = document.createElement('div');
          row.className = 'mcp-tool-row';

          const cb = document.createElement('input');
          cb.className = 'mcp-tool-toggle';
          cb.type = 'checkbox';
          cb.checked = isMcpToolEnabled(tn);
          
          const toolLabelEl = document.createElement('div');
          toolLabelEl.className = 'mcp-tool-label';
          toolLabelEl.textContent = tn;

          const desc = (typeof toolObj.description === 'string' && toolObj.description.trim()) ? toolObj.description.trim() : '';
          if (desc) {
            row.title = desc;
            toolLabelEl.title = desc;
          }

          cb.addEventListener('change', () => {
            setMcpToolEnabled(tn, !!cb.checked);
            updateMcpToolsStatus();
            scheduleSave('MCPÂ∑•ÂÖ∑');
          });

          row.addEventListener('click', (e) => {
            const target = e && e.target ? e.target : null;
            if (target && target.closest && target.closest('input')) return;
            cb.checked = !cb.checked;
            cb.dispatchEvent(new Event('change', { bubbles: true }));
          });

          row.appendChild(cb);
          row.appendChild(toolLabelEl);
          list.appendChild(row);
        }
        if (list.childNodes.length) body.appendChild(list);
        serverEl.appendChild(body);
        wrap.appendChild(serverEl);
      }
      updateMcpToolsStatus();
    }

    async function refreshMcpTools() {
      if (mcpToolsLoading) return;
      mcpToolsLoading = true;
      if (els.mcpToolsStatus) els.mcpToolsStatus.textContent = 'Âä†ËΩΩ‰∏≠...';
      try {
        const resp = await fetchJson('/api/mcp/tools', { method: 'GET' });
        if (resp && resp.success === false) {
          throw new Error(String(resp.error || 'Ëé∑ÂèñÂ§±Ë¥•'));
        }
        const data = resp?.data || {};
        renderMcpTools(data);
      } catch (e) {
        if (els.mcpToolsStatus) els.mcpToolsStatus.textContent = String(e && e.message ? e.message : e);
        if (els.mcpToolsList) els.mcpToolsList.textContent = 'Âä†ËΩΩÂ§±Ë¥•';
      } finally {
        mcpToolsLoading = false;
      }
    }

    function getFileExt(fileName) {
      const n = (fileName == null ? '' : String(fileName)).trim();
      const idx = n.lastIndexOf('.');
      if (idx < 0) return '';
      return n.slice(idx + 1).toLowerCase();
    }

    function isLikelyImageUrl(url) {
      const u = (url == null ? '' : String(url)).toLowerCase();
      const q = u.indexOf('?');
      const clean = q >= 0 ? u.slice(0, q) : u;
      return clean.endsWith('.png') || clean.endsWith('.jpg') || clean.endsWith('.jpeg') || clean.endsWith('.webp') || clean.endsWith('.gif') || clean.endsWith('.bmp') || clean.endsWith('.svg');
    }

    function isLikelyImageFile(file) {
      const type = (file && file.type) ? String(file.type).toLowerCase() : '';
      if (type.startsWith('image/')) return true;
      const ext = getFileExt(file && file.name ? file.name : '');
      return ['png', 'jpg', 'jpeg', 'webp', 'gif', 'bmp', 'svg'].includes(ext);
    }

    function renderMessageAttachments(attachmentsEl, msg) {
      if (!attachmentsEl) return;
      attachmentsEl.innerHTML = '';
      const atts = Array.isArray(msg?.attachments) ? msg.attachments : [];
      if (!atts.length) {
        attachmentsEl.style.display = 'none';
        return;
      }
      attachmentsEl.style.display = 'flex';

      for (const a of atts) {
        if (!a || !a.url) continue;
        const item = document.createElement('div');
        item.className = 'attachment-item';

        const head = document.createElement('div');
        head.className = 'attachment-head';

        const nameEl = document.createElement('div');
        nameEl.className = 'attachment-name';
        nameEl.textContent = a.name ? String(a.name) : (a.type ? String(a.type) : 'file');

        const link = document.createElement('a');
        link.className = 'attachment-link';

        link.href = String(removeDomainFromUrl(a.url));
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = 'ÊâìÂºÄ';

        head.appendChild(nameEl);
        head.appendChild(link);
        item.appendChild(head);

        const isImage = a.isImage === true || isLikelyImageUrl(a.url) || ['png', 'jpg', 'jpeg', 'webp', 'gif', 'bmp', 'svg'].includes(getFileExt(a.name || ''));
        if (isImage) {
          const preview = document.createElement('div');
          preview.className = 'attachment-preview';
          const img = document.createElement('img');
          img.src = String(a.url);
          img.alt = a.name ? String(a.name) : 'image';
          preview.appendChild(img);
          item.appendChild(preview);
        }

        attachmentsEl.appendChild(item);
      }

      if (!attachmentsEl.childNodes || attachmentsEl.childNodes.length === 0) {
        attachmentsEl.style.display = 'none';
      }
    }

    function removeDomainFromUrl(url) {
      try {
        const urlObj = new URL(url);
        return urlObj.pathname + urlObj.search + urlObj.hash;
      } catch (error) {
        return url;
      }
    }

    function renderAttachment() {
      const p = state.pendingAttachment;
      if (!p || !p.file) {
        els.attachInfo.style.display = 'none';
        els.attachName.textContent = '';
        return;
      }
      els.attachInfo.style.display = 'flex';
      els.attachName.textContent = p.originalName || p.file.name || '';
    }

    function clearAttachment() {
      state.pendingAttachment = null;
      if (els.attachInput) els.attachInput.value = '';
      renderAttachment();
    }

    function setAttachment(file) {
      if (!file) {
        clearAttachment();
        return;
      }
      state.pendingAttachment = { file, originalName: file.name || 'file', messageId: null, uploadedName: null };
      renderAttachment();
    }

    async function maybeUploadPendingAttachment() {
      const p = state.pendingAttachment;
      if (!p || !p.file || !p.messageId) return null;
      if (p.uploadedName) return p.uploadedName;

      const form = new FormData();
      form.append('file', p.file, p.originalName || p.file.name || 'file');
      const resp = await fetchJson('/api/chat/completion/file/upload', {
        method: 'POST',
        body: form,
        signal: state.abortController ? state.abortController.signal : undefined
      });
      const savedName = resp && resp.data && resp.data.name ? String(resp.data.name) : '';
      if (!savedName) throw new Error('‰∏ä‰º†Â§±Ë¥•ÔºöÁº∫Â∞ëËøîÂõûname');
      p.uploadedName = savedName;

      const m = state.messages.find(x => x.id === p.messageId);
      if (m) {
        const downloadPath = '/api/chat/completion/file/download?name=' + encodeURIComponent(savedName);
        const absoluteUrl = (typeof window !== 'undefined' && window.location && window.location.origin)
          ? (window.location.origin + downloadPath)
          : downloadPath;
        m.attachments = Array.isArray(m.attachments) ? m.attachments : [];
        const name = p.originalName || p.file.name || '';
        m.attachments.push({ type: 'file', url: absoluteUrl, name, isImage: isLikelyImageFile(p.file) });
        updateAttachments(m.id);
      }
      clearAttachment();
      return savedName;
    }

    const LZ_PREFIX = 'lz:';

    function lzCompressIfNeeded(text) {
      if (text == null) return text;
      const s = String(text);
      if (!s) return s;
      if (s.startsWith(LZ_PREFIX)) return s;
      if (s.length < 256) return s;
      try {
        const compressed = window.LZString?.compressToEncodedURIComponent ? window.LZString.compressToEncodedURIComponent(s) : null;
        if (!compressed) return s;
        return LZ_PREFIX + compressed;
      } catch (e) {
        return s;
      }
    }

    function lzDecompressIfNeeded(text) {
      if (text == null) return text;
      const s = String(text);
      if (!s) return s;
      if (!s.startsWith(LZ_PREFIX)) return s;
      const payload = s.slice(LZ_PREFIX.length);
      try {
        const out = window.LZString?.decompressFromEncodedURIComponent ? window.LZString.decompressFromEncodedURIComponent(payload) : null;
        return out == null ? s : out;
      } catch (e) {
        return s;
      }
    }

    function formatTime(ts) {
      if (!ts) return '';
      try {
        return new Date(ts).toLocaleString();
      } catch (e) {
        return String(ts);
      }
    }

    function normalizeSpeakerName(name, fallback) {
      const raw = (name == null ? '' : String(name)).trim();
      const cleaned = raw.replace(/[\r\n:]+/g, ' ').trim();
      return cleaned || fallback;
    }

    function getUserSpeakerName() {
      return normalizeSpeakerName(els.userName.value, 'User');
    }

    function getAssistantSpeakerName() {
      return normalizeSpeakerName(getCurrentCompletionTitle(), 'Assistant');
    }

    function getUserMessagePrefix() {
      return (els.userPrefix.value == null ? '' : String(els.userPrefix.value));
    }

    function getUserMessageSuffix() {
      return (els.userSuffix.value == null ? '' : String(els.userSuffix.value));
    }

    function getAssistantMessagePrefix() {
      return (els.assistantPrefix.value == null ? '' : String(els.assistantPrefix.value));
    }

    function getAssistantMessageSuffix() {
      return (els.assistantSuffix.value == null ? '' : String(els.assistantSuffix.value));
    }

    function getCurrentCompletionTitle() {
      const name = (els.titleInput.value || '').trim();
      return name || 'ÈªòËÆ§ËßíËâ≤';
    }

    function refreshCompletionTitleInMessages() {
      if (!state.currentCompletionId) return;
      const taskName = getCurrentCompletionTitle();
      const userName = getUserSpeakerName();
      for (const msgEl of els.chatList.querySelectorAll('.msg')) {
        const id = msgEl.dataset.id;
        if (!id) continue;
        const msg = getMessageById(id);
        if (!msg) continue;
        const left = msgEl.querySelector('.meta-left');
        if (!left) continue;
        left.textContent = msg.role === 'user' ? userName : (msg.role === 'assistant' ? taskName : 'Á≥ªÁªü');
      }
    }

    function openDrawer() {
      els.drawer.classList.add('open');
      els.drawer.setAttribute('aria-hidden', 'false');
      els.backdrop.classList.add('show');
    }

    function closeDrawer() {
      els.drawer.classList.remove('open');
      els.drawer.setAttribute('aria-hidden', 'true');
      els.backdrop.classList.remove('show');
    }

    function setBusyGenerating(isBusy) {
      els.sendBtn.disabled = isBusy;
      els.stopBtn.disabled = !isBusy;
      els.modelSelect.disabled = isBusy;
      els.refreshModels.disabled = isBusy;
      els.streamToggle.disabled = isBusy;
      els.thinkingToggle.disabled = isBusy;
      els.webSearchToggle.disabled = isBusy;
      if (els.refreshMcpTools) els.refreshMcpTools.disabled = isBusy;
      els.promptInput.disabled = false;
    }

    function setCompletionsLoading(isLoading) {
      state.isLoadingCompletions = isLoading;
      els.newSessionBtn.disabled = isLoading;
      els.reloadSessionsBtn.disabled = isLoading;
      els.drawerHint.textContent = isLoading ? 'Âä†ËΩΩ‰∏≠‚Ä¶' : '';
    }

    function maybeScrollToBottom() {
      if (!els.autoScroll.checked) return;
      els.chatList.scrollTop = els.chatList.scrollHeight;
    }

    function findMessageIndexById(id) {
      if (!id) return -1;
      return state.messages.findIndex(m => m && m.id === id);
    }

    function findMessageEntryById(id) {
      if (!id) return null;
      const msgIndex = state.messages.findIndex(m => m && m.id === id);
      if (msgIndex >= 0) return { list: state.messages, idx: msgIndex, msg: state.messages[msgIndex] };
      const logIndex = state.systemLogs.findIndex(m => m && m.id === id);
      if (logIndex >= 0) return { list: state.systemLogs, idx: logIndex, msg: state.systemLogs[logIndex] };
      return null;
    }

    function getMessageById(id) {
      const entry = findMessageEntryById(id);
      return entry ? entry.msg : null;
    }

    function upsertMessageDomEntry(id) {
      const key = String(id || '');
      if (!key) return null;
      const cached = state.messageEls.get(key) || {};
      let contentEl = cached.contentEl || null;
      let reasoningEl = cached.reasoningEl || null;
      let attachmentsEl = cached.attachmentsEl || null;
      let tokenEl = cached.tokenEl || null;

      if (!contentEl || !reasoningEl || !attachmentsEl || !tokenEl) {
        const wrap = els.chatList ? els.chatList.querySelector('.msg[data-id="' + key + '"]') : null;
        if (wrap) {
          if (!contentEl) contentEl = wrap.querySelector('.content');
          if (!reasoningEl) reasoningEl = wrap.querySelector('.reasoning pre');
          if (!attachmentsEl) attachmentsEl = wrap.querySelector('.attachments');
          if (!tokenEl) tokenEl = wrap.querySelector('.token-info');
        }
      }

      if (contentEl || reasoningEl || attachmentsEl || tokenEl) {
        const out = { contentEl, reasoningEl, attachmentsEl, tokenEl };
        state.messageEls.set(key, out);
        return out;
      }
      return null;
    }

    function openEditModal(messageId) {
      if (state.abortController) return;
      const entry = findMessageEntryById(messageId);
      if (!entry) return;
      const msg = entry.msg;
      state.editingMessageId = msg.id;
      els.editTextarea.value = msg.content || '';
      els.editModal.classList.add('show');
      els.editModal.setAttribute('aria-hidden', 'false');
      setTimeout(() => {
        try { els.editTextarea.focus(); } catch (e) { }
      }, 0);
    }

    function closeEditModal() {
      state.editingMessageId = null;
      els.editModal.classList.remove('show');
      els.editModal.setAttribute('aria-hidden', 'true');
    }

    function openKVCacheModal() {
      els.kvCacheModal.classList.add('show');
      els.kvCacheModal.setAttribute('aria-hidden', 'false');
    }

    function closeKVCacheModal() {
      els.kvCacheModal.classList.remove('show');
      els.kvCacheModal.setAttribute('aria-hidden', 'true');
    }

    function saveEditModal() {
      const id = state.editingMessageId;
      if (!id) return;
      const text = (els.editTextarea.value == null ? '' : String(els.editTextarea.value));
      updateMessage(id, text);
      scheduleSave('ÁºñËæëÊ∞îÊ≥°');
      closeEditModal();
    }

    function deleteMessage(messageId) {
      if (state.abortController) return;
      const entry = findMessageEntryById(messageId);
      if (!entry) return;
      if (!confirm('Á°ÆËÆ§Âà†Èô§ËØ•Ê∞îÊ≥°ÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ')) return;
      entry.list.splice(entry.idx, 1);
      rerenderAll();
      scheduleSave('Âà†Èô§Ê∞îÊ≥°');
    }

    function renderMessage(msg) {
      const wrap = document.createElement('div');
      wrap.className = 'msg ' + msg.role;
      wrap.dataset.id = msg.id;

      const avatar = msg.role === 'tool' ? null : (() => {
        const el = document.createElement('div');
        el.className = 'avatar';
        el.dataset.role = msg.role;
        if (msg.role === 'assistant') {
          el.classList.add('clickable');
          el.textContent = 'AI';
          applyAssistantAvatar(el);
        } else {
          el.textContent = msg.role === 'user' ? '‰Ω†' : 'SYS';
        }
        return el;
      })();

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const meta = document.createElement('div');
      meta.className = 'meta';
      const left = document.createElement('div');
      left.className = 'meta-left';
      const taskName = getCurrentCompletionTitle();
      const userName = getUserSpeakerName();
      left.textContent = msg.role === 'user' ? userName : (msg.role === 'assistant' ? taskName : (msg.role === 'tool' ? 'Tool' : 'Á≥ªÁªü'));

      const right = document.createElement('div');
      right.className = 'meta-right';

      const timeEl = document.createElement('div');
      timeEl.textContent = msg.ts ? new Date(msg.ts).toLocaleTimeString() : '';

      const actions = document.createElement('div');
      actions.className = 'msg-actions';

      function addAction(label, cls, onClick) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'msg-btn' + (cls ? (' ' + cls) : '');
        b.textContent = label;
        b.addEventListener('click', (e) => {
          e.stopPropagation();
          onClick();
        });
        actions.appendChild(b);
        return b;
      }

      if (msg.role === 'assistant' || msg.role === 'user') {
        addAction('ÈáçÁîüÊàê', 'ghost', () => regenerateMessage(msg.id));
      }
      addAction('ÁºñËæë', 'ghost', () => openEditModal(msg.id));
      addAction('Âà†Èô§', 'danger', () => deleteMessage(msg.id));

      right.appendChild(timeEl);
      right.appendChild(actions);
      meta.appendChild(left);
      meta.appendChild(right);

      const head = document.createElement('div');
      head.className = 'msg-head';
      if (avatar) head.appendChild(avatar);
      head.appendChild(meta);

      const content = document.createElement('div');
      content.className = 'content';
      const displayText = (msg && typeof msg.uiContent === 'string') ? msg.uiContent : (msg.content || '');
      renderMessageContentNow(content, displayText);

      let reasoningPre = null;
      const reasoningText = (typeof msg.reasoning === 'string' ? msg.reasoning : '');
      if (msg.role === 'assistant' && reasoningText.trim()) {
        const details = document.createElement('details');
        details.className = 'reasoning';
        const summary = document.createElement('summary');
        summary.textContent = 'ÊÄùËÄÉËøáÁ®ã';
        reasoningPre = document.createElement('pre');
        reasoningPre.textContent = reasoningText;
        details.appendChild(summary);
        details.appendChild(reasoningPre);
        bubble.appendChild(details);
      }

      if (msg.role === 'tool') {
        const details = document.createElement('details');
        details.className = 'tool-result';
        const summary = document.createElement('summary');
        const toolName = (msg && msg.tool_name != null) ? String(msg.tool_name) : 'Tool';
        const statusText = msg && msg.is_error ? 'Â§±Ë¥•' : 'ÁªìÊûú';
        summary.textContent = toolName + 'Ôºö' + statusText;
        details.appendChild(summary);
        details.appendChild(content);
        bubble.appendChild(details);
      } else {
        bubble.appendChild(content);
      }

      const tokenInfoEl = (msg.role === 'assistant')
        ? (() => {
          const el = document.createElement('div');
          el.className = 'token-info';
          el.style.display = 'none';
          bubble.appendChild(el);
          return el;
        })()
        : null;

      const attachmentsEl = document.createElement('div');
      attachmentsEl.className = 'attachments';
      bubble.appendChild(attachmentsEl);
      renderMessageAttachments(attachmentsEl, msg);

      wrap.appendChild(head);
      wrap.appendChild(bubble);

      state.messageEls.set(msg.id, { contentEl: content, reasoningEl: reasoningPre, attachmentsEl, tokenEl: tokenInfoEl });
      els.chatList.appendChild(wrap);
      syncMessageTimingsUi(msg.id);
      maybeScrollToBottom();
    }
    
    function buildAvatarUrl(charactorId) {
      const id = (charactorId == null ? '' : String(charactorId)).trim();
      if (!id) return '';
      const q = 'name=' + encodeURIComponent(id) + '&t=' + encodeURIComponent(String(state.avatarNonce || 0));
      return '/api/chat/completion/avatar/get?' + q;
    }
    
    function viewAvatar(charactorId) {
      const url = buildAvatarUrl(charactorId);
      if (!url) return;
      openAvatarViewer(url);
    }
    
    let avatarViewerOverlay = null;
    let avatarViewerKeydown = null;
    let avatarViewerResize = null;
    
    function closeAvatarViewer() {
      if (!avatarViewerOverlay) return;
      try {
        if (avatarViewerKeydown) document.removeEventListener('keydown', avatarViewerKeydown);
      } catch (e) { }
      try {
        if (avatarViewerResize) window.removeEventListener('resize', avatarViewerResize);
      } catch (e) { }
      try { avatarViewerOverlay.remove(); } catch (e) { }
      avatarViewerOverlay = null;
      avatarViewerKeydown = null;
      avatarViewerResize = null;
    }
    
    function openAvatarViewer(url) {
      if (!url) return;
      closeAvatarViewer();
      
      const overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.zIndex = '9999';
      overlay.style.background = 'rgba(0, 0, 0, 0.55)';
      overlay.style.backdropFilter = 'blur(6px)';
      overlay.style.cursor = 'zoom-out';
      
      const box = document.createElement('div');
      box.style.position = 'fixed';
      box.style.background = 'rgba(255, 255, 255, 0.95)';
      box.style.border = '1px solid var(--border)';
      box.style.borderRadius = '14px';
      box.style.boxShadow = 'var(--shadow)';
      box.style.overflow = 'hidden';
      box.style.cursor = 'default';
      
      const img = document.createElement('img');
      img.alt = 'avatar';
      img.decoding = 'async';
      img.loading = 'eager';
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'contain';
      img.style.display = 'block';
      img.style.cursor = 'pointer';
      img.addEventListener('click', (e) => {
        if (e) e.stopPropagation();
        closeAvatarViewer();
      });
      
      function layout() {
        const vw = window.innerWidth || 0;
        const vh = window.innerHeight || 0;
        const w = Math.max(1, Math.floor(vw * 0.92));
        const h = Math.max(1, Math.floor(vh * 0.92));
        const left = Math.floor((vw - w) / 2);
        const top = Math.floor((vh - h) / 2);
        box.style.left = left + 'px';
        box.style.top = top + 'px';
        box.style.width = w + 'px';
        box.style.height = h + 'px';
      }
      
      box.addEventListener('click', (e) => {
        e.stopPropagation();
      });
      overlay.addEventListener('click', () => closeAvatarViewer());
      
      avatarViewerKeydown = (e) => {
        if (e && e.key === 'Escape') closeAvatarViewer();
      };
      document.addEventListener('keydown', avatarViewerKeydown);
      
      avatarViewerResize = () => layout();
      window.addEventListener('resize', avatarViewerResize);
      
      box.appendChild(img);
      overlay.appendChild(box);
      document.body.appendChild(overlay);
      avatarViewerOverlay = overlay;
      
      layout();
      img.src = url;
    }
    
    function applyAssistantAvatar(avatarEl) {
      if (!avatarEl) return;
      const charactorId = state.currentCompletionId;
      if (!charactorId) return;
      const url = buildAvatarUrl(charactorId);
      if (!url) return;
      
      avatarEl.textContent = 'AI';
      for (const n of Array.from(avatarEl.querySelectorAll('img'))) {
        try { n.remove(); } catch (e) { }
      }
      
      const img = document.createElement('img');
      img.alt = 'avatar';
      img.decoding = 'async';
      img.loading = 'eager';
      img.style.display = 'none';
      img.addEventListener('load', () => {
        avatarEl.textContent = '';
        img.style.display = 'block';
        avatarEl.appendChild(img);
      });
      img.addEventListener('error', () => {
        try { img.remove(); } catch (e) { }
        avatarEl.textContent = 'AI';
      });
      avatarEl.appendChild(img);
      img.src = url;
    }
    
    let avatarUploadInput = null;
    
    function getAvatarUploadInput() {
      if (avatarUploadInput) return avatarUploadInput;
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.style.position = 'fixed';
      input.style.left = '-9999px';
      input.style.top = '-9999px';
      input.style.width = '1px';
      input.style.height = '1px';
      input.addEventListener('change', async (e) => {
        const file = e && e.target && e.target.files ? e.target.files[0] : null;
        input.value = '';
        if (!file) return;
        try {
          await uploadAvatarForCurrentRole(file);
        } catch (err) {
          alert('Â§¥ÂÉè‰∏ä‰º†Â§±Ë¥•Ôºö' + (err && err.message ? err.message : String(err)));
        }
      });
      document.body.appendChild(input);
      avatarUploadInput = input;
      return input;
    }
    
    async function uploadAvatarForCurrentRole(file) {
      if (!file) return;
      const maxBytes = 1024 * 1024;
      if (typeof file.size === 'number' && file.size > maxBytes) {
        throw new Error('Â§¥ÂÉèÂõæÁâáÈúÄÂ∞è‰∫é1MB');
      }
      const allow = ['png', 'jpg', 'jpeg', 'gif', 'webp'];
      const ext = getFileExt(file && file.name ? file.name : '');
      const type = (file && file.type) ? String(file.type).toLowerCase() : '';
      const typeOk = type === 'image/png' || type === 'image/jpeg' || type === 'image/gif' || type === 'image/webp';
      const extOk = allow.includes(ext);
      if (!typeOk && !extOk) throw new Error('‰ªÖÊîØÊåÅÂõæÁâáÊ†ºÂºè: png/jpg/jpeg/gif/webp');
      
      const id = state.currentCompletionId;
      if (!id) throw new Error('Áº∫Â∞ëËßíËâ≤ID');
      
      const fd = new FormData();
      fd.append('file', file, file.name || 'avatar');
      await fetchJson('/api/chat/completion/avatar/upload?name=' + encodeURIComponent(String(id)), {
        method: 'POST',
        body: fd
      });
      state.avatarNonce = Date.now();
      if (els.avatarSettingPreview) applyAssistantAvatar(els.avatarSettingPreview);
      rerenderAll();
    }

    function clearChatDom() {
      els.chatList.innerHTML = '';
      state.messageEls.clear();
    }

    function rerenderAll() {
      clearChatDom();
      for (const m of getRenderableMessages()) {
        if (m && m.hidden) continue;
        renderMessage(m);
      }
      maybeScrollToBottom();
    }

    function addMessage(role, content, extra) {
      const msg = { id: uid(), role, content: content || '', ts: Date.now(), order: nextMessageOrder() };
      if (extra && typeof extra === 'object') Object.assign(msg, extra);
      state.messages.push(msg);
      renderMessage(msg);
      return msg;
    }

    function addHiddenMessage(role, content, extra) {
      const msg = { id: uid(), role, content: content || '', ts: Date.now(), hidden: true, order: nextMessageOrder() };
      if (extra && typeof extra === 'object') Object.assign(msg, extra);
      state.messages.push(msg);
      return msg;
    }

    function addSystemLog(content, extra) {
      const msg = { id: uid(), role: 'system', content: content || '', ts: Date.now(), isSystemLog: true, order: nextMessageOrder() };
      if (extra && typeof extra === 'object') Object.assign(msg, extra);
      state.systemLogs.push(msg);
      renderMessage(msg);
      return msg;
    }

    function updateMessage(id, content) {
      const entry = upsertMessageDomEntry(id);
      const el = entry && entry.contentEl ? entry.contentEl : null;
      const m = getMessageById(id);
      if (m) m.content = content || '';
      const displayText = (m && typeof m.uiContent === 'string') ? m.uiContent : (content || '');
      if (el) requestRenderMessageContent(el, displayText);
      syncMessageTimingsUi(id);
      maybeScrollToBottom();
    }

    function setMessageUiContent(id, uiText) {
      const entry = upsertMessageDomEntry(id);
      const el = entry && entry.contentEl ? entry.contentEl : null;
      const m = getMessageById(id);
      if (m) m.uiContent = (uiText == null ? '' : String(uiText));
      if (el) requestRenderMessageContent(el, (uiText == null ? '' : String(uiText)));
      syncMessageTimingsUi(id);
      maybeScrollToBottom();
    }

    function setMessageUiAndContent(id, uiText, contentText) {
      const m = getMessageById(id);
      if (m) {
        m.content = contentText || '';
        m.uiContent = (uiText == null ? '' : String(uiText));
      }
      setMessageUiContent(id, uiText);
    }

    function setMessageToolCalls(id, toolCalls) {
      const m = getMessageById(id);
      if (!m) return;
      m.tool_calls = (Array.isArray(toolCalls) ? toolCalls : []);
      syncMessageTimingsUi(id);
    }

    function updateAttachments(id) {
      const m = getMessageById(id);
      if (!m) return;
      const entry = upsertMessageDomEntry(id);
      const attachmentsEl = entry && entry.attachmentsEl ? entry.attachmentsEl : null;
      if (!attachmentsEl) return;
      renderMessageAttachments(attachmentsEl, m);
      maybeScrollToBottom();
    }

    function updateReasoning(id, reasoning) {
      const entry = upsertMessageDomEntry(id);
      const pre = entry && entry.reasoningEl ? entry.reasoningEl : null;
      const reasoningText = (reasoning == null ? '' : String(reasoning));
      if (pre) {
        pre.textContent = reasoningText;
      } else if (reasoningText.trim()) {
        const wrap = els.chatList.querySelector('.msg.assistant[data-id="' + id + '"]');
        const bubble = wrap ? wrap.querySelector('.bubble') : null;
        if (bubble) {
          const details = document.createElement('details');
          details.className = 'reasoning';
          const summary = document.createElement('summary');
          summary.textContent = 'ÊÄùËÄÉËøáÁ®ã';
          const newPre = document.createElement('pre');
          newPre.textContent = reasoningText;
          details.appendChild(summary);
          details.appendChild(newPre);
          bubble.insertBefore(details, bubble.firstChild);
          upsertMessageDomEntry(id);
          const next = state.messageEls.get(String(id || '')) || {};
          state.messageEls.set(String(id || ''), {
            contentEl: next.contentEl || bubble.querySelector('.content'),
            reasoningEl: newPre,
            attachmentsEl: next.attachmentsEl || bubble.querySelector('.attachments'),
            tokenEl: next.tokenEl || bubble.querySelector('.token-info')
          });
        }
      }
      const m = getMessageById(id);
      if (m) m.reasoning = reasoningText;
      maybeScrollToBottom();
    }

    function buildPrompt(messages) {
      const lines = [];
      const sys = (els.systemPrompt.value || '').trim();
      if (sys) lines.push('System: ' + sys);
      lines.push('***');
      const userName = getUserSpeakerName();
      const assistantName = getAssistantSpeakerName();
      const userPrefix = getUserMessagePrefix();
      const userSuffix = getUserMessageSuffix();
      const assistantPrefix = getAssistantMessagePrefix();
      const assistantSuffix = getAssistantMessageSuffix();
      const history = Array.isArray(messages) ? messages : state.messages;
      for (const m of (Array.isArray(history) ? history : [])) {
        if (m && m.noContext) continue;
        if (m.role === 'system') {
          lines.push('System: ' + (m.content || ''));
        } else if (m.role === 'user') {
          let t = (m.content || '');
          const atts = Array.isArray(m.attachments) ? m.attachments : [];
          for (const a of atts) {
            if (a && a.url) {
              t += (t ? '\n' : '') + '[file] ' + String(a.url);
            }
          }
          lines.push(userName + ': ' + userPrefix + t + userSuffix);
        } else if (m.role === 'assistant') {
          lines.push(assistantName + ': ' + assistantPrefix + (m.content || '') + assistantSuffix);
        }
      }
      lines.push(assistantName + ': ' + assistantPrefix);
      return lines.join('\n');
    }

    function buildContent(messages, options) {
      const history = Array.isArray(messages) ? messages : state.messages;
      const includeNoContext = !!(options && options.includeNoContext);
      const out = [];
      const sys = (els.systemPrompt.value || '').trim();
      const rolePrompt = (els.rolePrompt.value || '').trim();

      if (sys) out.push({ role: 'system', content: sys });
      if (rolePrompt) out.push({ role: 'system', content: rolePrompt });
      out.push({ role: 'system', content: '[Start a new Chat]' });

      const userPrefix = getUserMessagePrefix();
      const userSuffix = getUserMessageSuffix();
      const assistantPrefix = getAssistantMessagePrefix();
      const assistantSuffix = getAssistantMessageSuffix();
      for (const m of (Array.isArray(history) ? history : [])) {
        if (m && m.noContext && !includeNoContext) continue;
        const role = m?.role;
        if (role !== 'system' && role !== 'user' && role !== 'assistant' && role !== 'tool') continue;
        const raw = (m?.content == null ? '' : String(m.content));
        if (role === 'system') {
          out.push({ role: 'system', content: raw });
        } else if (role === 'user') {
          if (userPrefix != null && userPrefix.length != 0)
            out.push({ role: 'user', content: userPrefix });
          const atts = Array.isArray(m?.attachments) ? m.attachments : [];
          if (atts.length > 0) {
            const parts = [];
            if (raw && raw.length) parts.push({ type: 'text', text: raw });
            for (const a of atts) {
              if (!a || !a.url) continue;
              parts.push({ type: 'file', text: String(a.url) });
            }
            out.push({ role: 'user', content: parts.length ? parts : raw });
          } else {
            out.push({ role: 'user', content: raw });
          }
          if (userSuffix != null && userSuffix.length != 0)
            out.push({ role: 'user', content: userSuffix });
        } else if (role === 'assistant') {
          const toolCalls = (Array.isArray(m?.tool_calls) ? m.tool_calls : null);
          if (toolCalls && toolCalls.length) {
            out.push({ role: 'assistant', content: raw, tool_calls: toolCalls });
          } else if (raw && raw.trim().length > 0) {
            if (assistantPrefix != null && assistantPrefix.length != 0)
              out.push({ role: 'assistant', content: assistantPrefix });
            out.push({ role: 'assistant', content: raw });
            if (assistantSuffix != null && assistantSuffix.length != 0)
              out.push({ role: 'assistant', content: assistantSuffix });
          }
        } else if (role === 'tool') {
          const toolCallId = (m?.tool_call_id == null ? '' : String(m.tool_call_id));
          out.push({ role: 'tool', content: raw, tool_call_id: toolCallId });
        }
      }
      return out;
    }

    function extractDeltaParts(json) {
      const c0 = json?.choices?.[0];
      if (!c0) return { content: '', reasoning: '' };
      let content = '';
      let reasoning = '';
      if (typeof c0.text === 'string') content = c0.text;
      if (typeof c0.delta?.content === 'string') content = c0.delta.content;
      if (typeof c0.message?.content === 'string') content = c0.message.content;
      if (typeof c0.delta?.reasoning_content === 'string') reasoning = c0.delta.reasoning_content;
      if (typeof c0.message?.reasoning_content === 'string') reasoning = c0.message.reasoning_content;
      if (typeof c0.reasoning_content === 'string') reasoning = c0.reasoning_content;
      if (typeof json?.reasoning_content === 'string') reasoning = json.reasoning_content;
      return { content, reasoning };
    }

    function getTimingsFromResponse(json) {
      const t = json?.timings;
      if (t && typeof t === 'object') return t;
      return null;
    }

    function normalizeTimingsNumber(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function formatTimingsText(timings) {
      if (!timings) return '';
      const cacheN = normalizeTimingsNumber(timings.cache_n) ?? 0;
      const promptN = normalizeTimingsNumber(timings.prompt_n) ?? 0;
      const predictedN = normalizeTimingsNumber(timings.predicted_n) ?? 0;
      const promptTotal = cacheN + promptN;
      const total = promptTotal + predictedN;
      if (!Number.isFinite(total) || total <= 0) return '';
      return `‰ª§ÁâåÁªüËÆ°ÔºöÊèêÁ§∫ËØç ${promptTotal}ÔºàÁºìÂ≠ò ${cacheN} + Êñ∞Â¢û ${promptN}ÔºâÔºåÁîüÊàê ${predictedN}ÔºåÂêàËÆ° ${total}`;
    }

    function upsertTimingsLog(messageId, timings) {
      if (!messageId || !timings) return;
      state.timingsLog = Array.isArray(state.timingsLog) ? state.timingsLog : [];
      const id = String(messageId);
      for (let i = state.timingsLog.length - 1; i >= 0; i--) {
        const it = state.timingsLog[i];
        if (it && String(it.messageId) === id) {
          it.ts = Date.now();
          it.timings = timings;
          return;
        }
      }
      state.timingsLog.push({ messageId: id, ts: Date.now(), timings });
    }

    function getLatestTimingsFromLog(messageId) {
      const id = String(messageId || '');
      const list = Array.isArray(state.timingsLog) ? state.timingsLog : [];
      for (let i = list.length - 1; i >= 0; i--) {
        const it = list[i];
        if (it && String(it.messageId) === id && it.timings) return it.timings;
      }
      return null;
    }

    function shouldShowTimingsForMessage(m) {
      if (!m || m.role !== 'assistant') return false;
      if (Array.isArray(m.tool_calls) && m.tool_calls.length) return false;
      const displayText = (m && typeof m.uiContent === 'string') ? m.uiContent : (m && m.content != null ? String(m.content) : '');
      if (!String(displayText).trim()) return false;
      return true;
    }

    function syncMessageTimingsUi(messageId) {
      const id = String(messageId || '');
      if (!id) return;
      const m = getMessageById(id);
      const timings = (m && m.timings) ? m.timings : getLatestTimingsFromLog(id);

      const entry = upsertMessageDomEntry(id);
      const tokenEl = entry && entry.tokenEl ? entry.tokenEl : null;
      if (!tokenEl) return;

      const text = formatTimingsText(timings);
      const show = !!text && shouldShowTimingsForMessage(m);
      tokenEl.textContent = show ? text : '';
      tokenEl.style.display = show ? '' : 'none';
    }

    function setMessageTimings(messageId, timings) {
      if (!messageId || !timings) return;
      const m = getMessageById(messageId);
      if (m) m.timings = timings;
      upsertTimingsLog(messageId, timings);
      syncMessageTimingsUi(messageId);
    }

    function getToolCallsFromResponse(json) {
      if (!json) return [];
      const direct = json?.tool_calls;
      if (Array.isArray(direct) && direct.length) return direct;
      const c0 = json?.choices?.[0];
      const msg = c0?.message;
      if (Array.isArray(msg?.tool_calls) && msg.tool_calls.length) return msg.tool_calls;
      const delta = c0?.delta;
      if (Array.isArray(delta?.tool_calls) && delta.tool_calls.length) return delta.tool_calls;
      return [];
    }

    function mergeToolCallsDelta(target, deltaToolCalls) {
      const out = Array.isArray(target) ? target : [];
      if (!Array.isArray(deltaToolCalls) || !deltaToolCalls.length) return out;
      for (let i = 0; i < deltaToolCalls.length; i++) {
        const d = deltaToolCalls[i];
        if (!d) continue;
        const idx = (Number.isFinite(d.index) ? d.index : i);
        if (!out[idx]) out[idx] = { id: '', type: d.type || 'function', function: { name: '', arguments: '' } };
        const cur = out[idx];
        if (typeof d.id === 'string' && d.id) cur.id = d.id;
        const fn = d.function || {};
        if (typeof fn.name === 'string' && fn.name) {
          cur.function = cur.function || {};
          cur.function.name = fn.name;
        }
        if (typeof fn.arguments === 'string' && fn.arguments) {
          cur.function = cur.function || {};
          cur.function.arguments = (cur.function.arguments || '') + fn.arguments;
        }
      }
      return out.filter(Boolean);
    }

    async function consumeSseStream(res, assistantMsgId) {
      const reader = res.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let text = '';
      let reasoning = '';
      let toolCallsAgg = [];
      let latestTimings = null;
      let revealed = false;
      let gotDone = false;
      let sawAnyUsefulDelta = false;
      let rawErrorCandidate = '';

      function revealIfNeeded() {
        if (revealed) return;
        const m = getMessageById(assistantMsgId);
        if (m && m.hidden === true) {
          m.hidden = false;
          rerenderAll();
        }
        revealed = true;
      }

      function shouldRevealNow(parts, tcs) {
        const hasText = !!(parts && ((parts.content && String(parts.content).length) || (parts.reasoning && String(parts.reasoning).length)));
        const hasTools = Array.isArray(tcs) && tcs.length > 0;
        return hasText || hasTools;
      }
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split(/\r?\n/);
        buffer = lines.pop() || '';
        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          const data = line.slice(6).trim();
          if (data === '[DONE]') {
            gotDone = true;
            if (!revealed && (String(text).trim() || String(reasoning).trim() || (Array.isArray(toolCallsAgg) && toolCallsAgg.length))) {
              revealIfNeeded();
            }
            if (latestTimings) {
              setMessageTimings(assistantMsgId, latestTimings);
            }
            updateMessage(assistantMsgId, text);
            if (reasoning) updateReasoning(assistantMsgId, reasoning);
            return { content: text, reasoning, tool_calls: toolCallsAgg, timings: latestTimings };
          }
          try {
            const json = JSON.parse(data);
            if (json?.error) {
              const errMsg = (json?.error?.message != null ? String(json.error.message) : String(json.error));
              const err = new Error(errMsg || 'ËØ∑Ê±ÇÂ§±Ë¥•');
              err.name = 'SseError';
              throw err;
            }
            const parts = extractDeltaParts(json);
            const tcs = getToolCallsFromResponse(json);
            const timings = getTimingsFromResponse(json);
            if (timings) latestTimings = timings;
            const useful = shouldRevealNow(parts, tcs);
            if (!revealed && useful) {
              revealIfNeeded();
            }
            if (useful) sawAnyUsefulDelta = true;
            if (Array.isArray(tcs) && tcs.length) {
              toolCallsAgg = mergeToolCallsDelta(toolCallsAgg, tcs);
              setMessageToolCalls(assistantMsgId, toolCallsAgg);
            }
            if (parts.reasoning) {
              reasoning += parts.reasoning;
              updateReasoning(assistantMsgId, reasoning);
            }
            if (parts.content) {
              text += parts.content;
              updateMessage(assistantMsgId, text);
            }
          } catch (e) {
            if (e && e.name === 'SseError') throw e;
            if (!sawAnyUsefulDelta && !rawErrorCandidate && data) rawErrorCandidate = String(data).slice(0, 800);
          }
        }
      }
      if (!gotDone && !sawAnyUsefulDelta) {
        const err = new Error(rawErrorCandidate || 'ËØ∑Ê±ÇÂ§±Ë¥•');
        err.name = 'SseError';
        throw err;
      }
      if (!revealed && (String(text).trim() || String(reasoning).trim() || (Array.isArray(toolCallsAgg) && toolCallsAgg.length))) {
        revealIfNeeded();
      }
      if (latestTimings) {
        setMessageTimings(assistantMsgId, latestTimings);
      }
      updateMessage(assistantMsgId, text);
      if (reasoning) updateReasoning(assistantMsgId, reasoning);
      return { content: text, reasoning, tool_calls: toolCallsAgg, timings: latestTimings };
    }

    function getPreparedQueryFromMessages(messages) {
      const history = Array.isArray(messages) ? messages : state.messages;
      for (let i = history.length - 1; i >= 0; i--) {
        const m = history[i];
        if (!m || m.role !== 'user') continue;
        const raw = (m.content == null ? '' : String(m.content)).trim();
        if (raw) return raw;
      }
      return '';
    }

    function getWebSearchMcpTools(preparedQuery) {
      const q = (preparedQuery == null ? '' : String(preparedQuery)).trim();
      const prepared = q ? (q + '\n') : '';
      return [{
        type: 'function',
        function: {
          name: 'builtin_web_search',
          description: 'Web search tool for finding current information, news, and real-time data from the internet.\n\nThis tool has been configured with search parameters based on the conversation context:\n- Prepared queries: \"' + prepared + '\"\n\nYou can use this tool as-is to search with the prepared queries, or provide additionalContext to refine or replace the search terms.',
          parameters: {
            $schema: 'http://json-schema.org/draft-07/schema#',
            type: 'object',
            properties: {
              additionalContext: {
                description: 'Optional additional context, keywords, or specific focus to enhance the search',
                type: 'string'
              }
            },
            required: ['additionalContext'],
            additionalProperties: false
          }
        }
      }];
    }

    function getEnabledMcpToolsForRequest() {
      const enabled = Array.isArray(state.enabledMcpTools) ? state.enabledMcpTools : [];
      if (!enabled.length) return [];
      const data = state?.mcpToolsData || {};
      let tools = Array.isArray(data?.tools) ? data.tools : [];
      if (!tools.length) {
        const servers = data?.servers;
        if (servers && typeof servers === 'object') {
          const merged = [];
          for (const server of Object.values(servers)) {
            const toolArr = Array.isArray(server?.tools) ? server.tools : [];
            for (const t of toolArr) merged.push(t);
          }
          tools = merged;
        }
      }
      if (!tools.length) return [];

      const toolByName = new Map();
      for (const t of tools) {
        const tn = normalizeToolName(t?.name);
        if (!tn) continue;
        if (!toolByName.has(tn)) toolByName.set(tn, t);
      }

      const out = [];
      const seen = new Set();
      for (const n of enabled) {
        const tn = normalizeToolName(n);
        if (!tn || seen.has(tn)) continue;
        const toolObj = toolByName.get(tn);
        if (!toolObj) continue;
        const def = buildOpenAiToolFromMcpTool(toolObj);
        if (!def?.function?.name) continue;
        out.push(def);
        seen.add(tn);
      }
      return out;
    }

    function buildOpenAiToolFromMcpTool(toolObj) {
      const toolName = normalizeToolName(toolObj?.name);
      const desc = (typeof toolObj?.description === 'string' ? toolObj.description : '').trim();
      const inputSchema = toolObj?.inputSchema;
      const parameters = (inputSchema && typeof inputSchema === 'object')
        ? inputSchema
        : {
          $schema: 'http://json-schema.org/draft-07/schema#',
          type: 'object',
          properties: {},
          additionalProperties: true
        };
      return {
        type: 'function',
        function: {
          name: toolName,
          description: desc || ('MCP tool: ' + toolName),
          parameters
        }
      };
    }

    async function executeToolCalls(toolCalls, preparedQuery) {
      const results = [];
      let hasError = false;
      for (const tc of (Array.isArray(toolCalls) ? toolCalls : [])) {
        const toolCallId = (typeof tc?.id === 'string' && tc.id) ? tc.id : uid();
        const fn = tc?.function || {};
        const name = (typeof fn?.name === 'string' ? fn.name : (typeof tc?.name === 'string' ? tc.name : ''));
        const args = (typeof fn?.arguments === 'string' ? fn.arguments : (typeof tc?.arguments === 'string' ? tc.arguments : ''));
        try {
          const resp = await fetchJson('/api/tools/execute', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tool_name: name, arguments: args, preparedQuery })
          });
          if (resp && resp.success === false) {
            hasError = true;
            const errText = String(resp.error || 'Â∑•ÂÖ∑ÊâßË°åÂ§±Ë¥•');
            results.push({
              tool_call_id: toolCallId,
              tool_name: name,
              is_error: true,
              error: errText,
              content: JSON.stringify({ success: false, tool_name: name, error: errText })
            });
            continue;
          }
          const out = resp?.data?.content;
          const outText = (out == null ? '' : String(out));
          let uiText = outText;
          if (!String(uiText).trim()) {
            try { uiText = JSON.stringify(resp); } catch (e) { uiText = outText; }
          }
          results.push({ tool_call_id: toolCallId, tool_name: name, is_error: false, content: outText, ui: uiText });
        } catch (e) {
          hasError = true;
          const errText = String(e && e.message ? e.message : e);
          results.push({
            tool_call_id: toolCallId,
            tool_name: name,
            is_error: true,
            error: errText,
            content: JSON.stringify({ success: false, tool_name: name, error: errText })
          });
        }
      }
      return { results, hasError };
    }

    function currentParams() {
      const rawMinP = String(els.minP.value || '').trim();
      const rawRepeatPenalty = String(els.repeatPenalty.value || '').trim();
      const stopLines = String(els.stopSequences.value || '')
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean);

      const min_p = rawMinP ? Number(rawMinP) : undefined;
      const repeat_penalty = rawRepeatPenalty ? Number(rawRepeatPenalty) : undefined;
      const stop = stopLines.length ? stopLines : undefined;

      return {
        max_tokens: Number(els.maxTokens.value || 1024),
        temperature: Number(els.temperature.value || 0.7),
        top_p: Number(els.topP.value || 1),
        min_p: (Number.isFinite(min_p) ? min_p : undefined),
        repeat_penalty: (Number.isFinite(repeat_penalty) ? repeat_penalty : undefined),
        stop
      };
    }

    async function generateIntoMessage(contextMessages, assistantMsgId) {
      const model = els.modelSelect.value || '';
      const params = currentParams();
      state.abortController = new AbortController();
      setStatus('ÁîüÊàê‰∏≠‚Ä¶');
      setBusyGenerating(true);
      setSaveHint('');

      try {
        await maybeUploadPendingAttachment();
        const isChat = state.apiModel === 1;
        const useStream = !!els.streamToggle.checked;
        let allowTools = true;
        let currentAssistantId = assistantMsgId;
        let toolRounds = 0;
        let includeNoContextInRequest = false;
        let stopAfterThisRequest = false;
        let pendingAssistantExtra = null;

        if (isChat && Array.isArray(state.enabledMcpTools) && state.enabledMcpTools.length && !state.mcpToolsData) {
          await refreshMcpTools();
        }

        while (true) {
          const url = isChat ? '/v1/chat/completions' : '/v1/completions';
          const stop = (params.stop != null
            ? params.stop
            : (isChat ? ["<|endoftext|>"] : ['\n' + getUserSpeakerName(), '\n***']));
          const body = isChat
            ? (() => {
              const b = {
                model,
                messages: buildContent(state.messages, { includeNoContext: includeNoContextInRequest }),
                max_tokens: params.max_tokens,
                temperature: params.temperature,
                top_p: params.top_p,
                min_p: params.min_p,
                repeat_penalty: params.repeat_penalty,
                enable_thinking: !!els.thinkingToggle.checked,
                stream: useStream,
                stop
              };
              if (allowTools) {
                const preparedQuery = getPreparedQueryFromMessages(state.messages);
                const allTools = [];
                if (!!els.webSearchToggle.checked) {
                  allTools.push(...getWebSearchMcpTools(preparedQuery));
                }
                allTools.push(...getEnabledMcpToolsForRequest());
                allowTools = allTools.length > 0;
                if (allowTools) {
                  b.tools = allTools;
                  b.tool_choice = 'auto';
                  b.parse_tool_calls = true;
                }
              }
              return b;
            })()
            : {
              model,
              prompt: buildPrompt(state.messages),
              max_tokens: params.max_tokens,
              temperature: params.temperature,
              top_p: params.top_p,
              min_p: params.min_p,
              repeat_penalty: params.repeat_penalty,
              enable_thinking: !!els.thinkingToggle.checked,
              stream: useStream,
              stop
            };

          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: state.abortController.signal
          });

          if (!res.ok) {
            const t = await res.text();
            let msg = t;
            try {
              const j = t ? JSON.parse(t) : null;
              msg = j?.message || j?.error?.message || t;
              setStatus(msg);
            } catch (e) { }
            throw new Error(msg || ('HTTP ' + res.status));
          }

          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let toolCalls = [];
          if (ct.includes('text/event-stream')) {
            if (!currentAssistantId) {
              const extra = (pendingAssistantExtra && typeof pendingAssistantExtra === 'object') ? pendingAssistantExtra : null;
              pendingAssistantExtra = null;
              const placeholder = addHiddenMessage('assistant', '', extra || undefined);
              currentAssistantId = placeholder.id;
            }
            const r = await consumeSseStream(res, currentAssistantId);
            toolCalls = r?.tool_calls || [];
          } else {
            if (!currentAssistantId) {
              const extra = (pendingAssistantExtra && typeof pendingAssistantExtra === 'object') ? pendingAssistantExtra : null;
              pendingAssistantExtra = null;
              const placeholder = addMessage('assistant', '', extra || undefined);
              currentAssistantId = placeholder.id;
            }
            const data = await res.json();
            const parts = extractDeltaParts(data);
            toolCalls = getToolCallsFromResponse(data);
            if (Array.isArray(toolCalls) && toolCalls.length) {
              setMessageToolCalls(currentAssistantId, toolCalls);
            }
            updateMessage(currentAssistantId, parts.content || '');
            if (parts.reasoning) updateReasoning(currentAssistantId, parts.reasoning);
            const timings = getTimingsFromResponse(data);
            if (timings) setMessageTimings(currentAssistantId, timings);
          }

          if (stopAfterThisRequest) {
            break;
          }

          if (isChat && allowTools && Array.isArray(toolCalls) && toolCalls.length && toolRounds < 3) {
            setStatus('Ë∞ÉÁî®Â∑•ÂÖ∑‰∏≠‚Ä¶');
            setMessageToolCalls(currentAssistantId, toolCalls);
            const curMsg = getMessageById(currentAssistantId);
            const curText = (curMsg && curMsg.content != null) ? String(curMsg.content).trim() : '';
            if (!curText) {
              const toolNames = toolCalls
                .map(tc => (tc && tc.function && typeof tc.function.name === 'string') ? tc.function.name : (tc && typeof tc.name === 'string' ? tc.name : ''))
                .map(s => (s == null ? '' : String(s)).trim())
                .filter(Boolean)
                .join(', ');
              setMessageUiAndContent(currentAssistantId, toolNames ? ('Ë∞ÉÁî®Â∑•ÂÖ∑Ôºö' + toolNames) : 'Ë∞ÉÁî®Â∑•ÂÖ∑', '');
            }
            const preparedQuery = getPreparedQueryFromMessages(state.messages);
            const r0 = await executeToolCalls(toolCalls, preparedQuery);
            const toolResults = r0?.results || [];
            const hasError = !!r0?.hasError;
            for (const r of toolResults) {
              addMessage('tool', (r && r.content != null ? String(r.content) : ''), {
                tool_call_id: r && r.tool_call_id != null ? String(r.tool_call_id) : '',
                tool_name: r && r.tool_name != null ? String(r.tool_name) : '',
                is_error: !!(r && r.is_error),
                uiContent: r && r.ui != null ? String(r.ui) : undefined,
                noContext: hasError
              });
            }
            if (hasError) {
              const errTexts = toolResults.filter(x => x && x.is_error && x.error).map(x => String(x.error));
              const errText = errTexts.length ? errTexts.join('\n') : 'Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•';
              addSystemLog('Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•Ôºö' + errText, { noContext: true });
              setMessageUiAndContent(currentAssistantId, 'Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•', '');
              currentAssistantId = null;
              pendingAssistantExtra = { noContext: true };
              toolRounds++;
              allowTools = false;
              includeNoContextInRequest = true;
              stopAfterThisRequest = true;
              setStatus('Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•ÔºåÁªßÁª≠ÁîüÊàêËØ¥Êòé‚Ä¶');
              continue;
            }
            currentAssistantId = null;
            pendingAssistantExtra = null;
            toolRounds++;
            setStatus('Â∑•ÂÖ∑Ë∞ÉÁî®ÂÆåÊàêÔºåÁªßÁª≠ÁîüÊàê‚Ä¶');
            continue;
          }

          break;
        }

        setStatus('ÂÆåÊàê');
        scheduleSave('ÂÆåÊàê');
      } catch (e) {
        if (currentAssistantId) {
          const m = getMessageById(currentAssistantId);
          const canDrop = m && m.role === 'assistant'
            && m.hidden === true
            && !String(m.content || '').trim()
            && !String(m.uiContent || '').trim()
            && !String(m.reasoning || '').trim()
            && !(Array.isArray(m.tool_calls) && m.tool_calls.length)
            && !(Array.isArray(m.attachments) && m.attachments.length);
          if (canDrop) {
            const entry = findMessageEntryById(currentAssistantId);
            if (entry) entry.list.splice(entry.idx, 1);
          }
        }
        if (e.name === 'AbortError') {
          setStatus('Â∑≤ÂÅúÊ≠¢');
          scheduleSave('ÂÅúÊ≠¢');
        } else {
          setStatus('ÁîüÊàêÂ§±Ë¥•Ôºö' + e.message);
          addSystemLog('ÁîüÊàêÂ§±Ë¥•Ôºö' + e.message);
          scheduleSave('Â§±Ë¥•');
        }
      } finally {
        setBusyGenerating(false);
        state.abortController = null;
      }
    }

    async function regenerateMessage(messageId) {
      if (state.abortController) return;
      const idx = findMessageIndexById(messageId);
      if (idx < 0) return;
      const msg = state.messages[idx];
      if (msg.role === 'system') return;

      const hasLater = idx < state.messages.length - 1;
      if (hasLater) {
        if (!confirm('Â∞ÜÂà†Èô§ËØ•Ê∞îÊ≥°‰πãÂêéÁöÑÂØπËØùÂÜÖÂÆπÂπ∂‰ªéËøôÈáåÈáçÊñ∞ÁîüÊàêÔºåÁªßÁª≠Ôºü')) return;
      }

      if (msg.role === 'assistant') {
        state.messages = state.messages.slice(0, idx + 1);
        rerenderAll();
        updateMessage(msg.id, '');
        
        await generateIntoMessage(state.messages.slice(0, idx), msg.id);
        scheduleSave('ÈáçÁîüÊàê');
        return;
      }

      if (msg.role === 'user') {
        state.messages = state.messages.slice(0, idx + 1);
        rerenderAll();
        
        if (!!els.streamToggle.checked) {
          await generateIntoMessage(state.messages, null);
        } else {
          const assistantMsg = addMessage('assistant', '');
          await generateIntoMessage(state.messages, assistantMsg.id);
        }
        scheduleSave('ÈáçÁîüÊàê');
      }
    }

    function scheduleSave(reason) {
      if (!state.currentCompletionId) return;
      if (state.saveTimer) clearTimeout(state.saveTimer);
      state.saveTimer = setTimeout(() => saveCompletion(reason).catch(() => { }), 450);
    }

    function buildParamsJson() {
      return JSON.stringify({
        model: els.modelSelect.value || '',
        apiModel: state.apiModel,
        userName: (els.userName.value || '').trim(),
        userPrefix: (els.userPrefix.value == null ? '' : String(els.userPrefix.value)),
        userSuffix: (els.userSuffix.value == null ? '' : String(els.userSuffix.value)),
        assistantPrefix: (els.assistantPrefix.value == null ? '' : String(els.assistantPrefix.value)),
        assistantSuffix: (els.assistantSuffix.value == null ? '' : String(els.assistantSuffix.value)),
        enableThinking: !!els.thinkingToggle.checked,
        enableWebSearch: !!els.webSearchToggle.checked,
        enabledMcpTools: (Array.isArray(state.enabledMcpTools) ? state.enabledMcpTools : []),
        params: currentParams(),
        history: state.messages,
        systemLogs: state.systemLogs
      });
    }

    function buildTimingsJson() {
      return JSON.stringify(Array.isArray(state.timingsLog) ? state.timingsLog : []);
    }

    async function saveCompletion(reason) {
      if (!state.currentCompletionId) return;
      const payload = {
        id: Number(state.currentCompletionId),
        title: els.titleInput.value || '',
        prompt: lzCompressIfNeeded(els.rolePrompt.value || ''),
        systemPrompt: lzCompressIfNeeded(els.systemPrompt.value || ''),
        paramsJson: lzCompressIfNeeded(buildParamsJson()),
        timingsJson: lzCompressIfNeeded(buildTimingsJson()),
        apiModel: state.apiModel,
        createdAt: Number(state.currentCreatedAt || 0),
        updatedAt: Date.now()
      };
      setSaveHint('‰øùÂ≠ò‰∏≠‚Ä¶');
      await fetchJson('/api/chat/completion/save?name=' + encodeURIComponent(state.currentCompletionId), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      state.lastSavedAt = Date.now();
      setSaveHint((reason ? ('Â∑≤‰øùÂ≠òÔºà' + reason + 'Ôºâ') : 'Â∑≤‰øùÂ≠ò') + ' ¬∑ ' + new Date(state.lastSavedAt).toLocaleTimeString());
      await loadCompletions(false);
    }

    async function loadModels() {
      if (state.isLoadingModels) return;
      state.isLoadingModels = true;
      try {
        setStatus('Âä†ËΩΩÊ®°Âûã‚Ä¶');
        els.refreshModels.disabled = true;
        const data = await fetchJson('/v1/models', { method: 'GET' });
        const models = Array.isArray(data?.data) ? data.data : [];
        const current = els.modelSelect.value;
        els.modelSelect.innerHTML = '';
        if (models.length === 0) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Êú™ÂèëÁé∞Â∑≤Âä†ËΩΩÊ®°Âûã';
          els.modelSelect.appendChild(opt);
          els.modelSelect.disabled = true;
        } else {
          els.modelSelect.disabled = false;
          for (const m of models) {
            const opt = document.createElement('option');
            opt.value = m.id;
            opt.textContent = m.id;
            els.modelSelect.appendChild(opt);
          }
          if (current && models.some(m => m.id === current)) {
            els.modelSelect.value = current;
          }
        }
        setStatus('Â∞±Áª™');
      } catch (e) {
        setStatus('Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•Ôºö' + e.message);
      } finally {
        state.isLoadingModels = false;
        els.refreshModels.disabled = false;
      }
    }

    function renderCompletions(items, currentId) {
      if (!Array.isArray(items)) items = [];
      els.sessionsList.innerHTML = '';
      if (items.length === 0) {
        const li = document.createElement('li');
        li.className = 'session-item';
        li.innerHTML = '<div class="session-meta"><div class="session-title">ÊöÇÊó†ËßíËâ≤</div><div class="session-sub">ÁÇπÂáª‚ÄúÊñ∞Âª∫ËßíËâ≤‚ÄùÂàõÂª∫ËßíËâ≤</div></div>';
        li.style.cursor = 'default';
        els.sessionsList.appendChild(li);
        return;
      }
      for (const s of items) {
        const li = document.createElement('li');
        const id = s?.id == null ? '' : String(s.id);
        li.className = 'session-item' + (id && id === String(currentId || '') ? ' active' : '');
        li.dataset.id = id;
        const title = s?.title || ('ËßíËâ≤ ' + id);
        const sub = (s?.updatedAt ? ('Êõ¥Êñ∞Ôºö' + formatTime(s.updatedAt)) : (s?.createdAt ? ('ÂàõÂª∫Ôºö' + formatTime(s.createdAt)) : ''));
        li.innerHTML = `
          <div class="session-meta">
            <div class="session-title"></div>
            <div class="session-sub"></div>
          </div>
          <button class="btn icon-btn danger" type="button" data-action="delete" title="Âà†Èô§">√ó</button>
        `;
        li.querySelector('.session-title').textContent = title;
        li.querySelector('.session-sub').textContent = sub;
        els.sessionsList.appendChild(li);
      }
    }

    async function loadCompletions(ensureCurrent) {
      setCompletionsLoading(true);
      try {
        const data = await fetchJson('/api/chat/completion/list', { method: 'GET' });
        const items = Array.isArray(data?.data) ? data.data : [];
        let current = state.currentCompletionId;
        if (!current && items[0]?.id != null) current = String(items[0].id);
        renderCompletions(items, current);
        if (ensureCurrent) {
          if (!current) {
            await createCompletion();
            return;
          }
          state.currentCompletionId = String(current);
          await loadCompletion(current);
        }
      } catch (e) {
        els.sessionsList.innerHTML = '';
        const li = document.createElement('li');
        li.className = 'session-item';
        li.innerHTML = '<div class="session-meta"><div class="session-title">Âä†ËΩΩÂ§±Ë¥•</div><div class="session-sub"></div></div>';
        li.querySelector('.session-sub').textContent = e.message;
        li.style.cursor = 'default';
        els.sessionsList.appendChild(li);
      } finally {
        setCompletionsLoading(false);
      }
    }

    async function createCompletion() {
      setCompletionsLoading(true);
      try {
        const seedTitle = 'ÈªòËÆ§ËßíËâ≤-' + Date.now();
        const data = await fetchJson('/api/chat/completion/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: seedTitle })
        });
        const created = data?.data || {};
        if (created.id == null) throw new Error('Êñ∞Âª∫Â§±Ë¥•ÔºöÁº∫Â∞ëËßíËâ≤ID');
        state.currentCompletionId = String(created.id);
        state.currentCreatedAt = Number(created.createdAt || 0);
        await loadCompletions(false);
        await loadCompletion(state.currentCompletionId);
      } catch (e) {
        els.drawerHint.textContent = 'Êñ∞Âª∫Â§±Ë¥•Ôºö' + e.message;
      } finally {
        setCompletionsLoading(false);
      }
    }

    async function deleteCompletion(id) {
      if (!id) return;
      if (!confirm('Á°ÆËÆ§Âà†Èô§ËØ•ËßíËâ≤ÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ')) return;
      setCompletionsLoading(true);
      try {
        await fetchJson('/api/chat/completion/delete?name=' + encodeURIComponent(id), { method: 'DELETE' });
        if (String(id) === String(state.currentCompletionId || '')) {
          state.currentCompletionId = null;
          state.currentCreatedAt = 0;
        }
        await loadCompletions(false);
        if (state.currentCompletionId) {
          await loadCompletion(state.currentCompletionId);
        } else {
          els.titleInput.value = '';
          els.systemPrompt.value = '';
          els.rolePrompt.value = '';
          state.messages = [];
          state.systemLogs = [];
          state.msgSeq = 0;
          rerenderAll();
        }
      } catch (e) {
        els.drawerHint.textContent = 'Âà†Èô§Â§±Ë¥•Ôºö' + e.message;
      } finally {
        setCompletionsLoading(false);
      }
    }

    async function switchCompletion(id) {
      if (!id) return;
      if (String(id) === String(state.currentCompletionId || '')) return;
      setCompletionsLoading(true);
      try {
        state.currentCompletionId = String(id);
        await loadCompletions(false);
        await loadCompletion(state.currentCompletionId);
        closeDrawer();
      } catch (e) {
        els.drawerHint.textContent = 'ÂàáÊç¢Â§±Ë¥•Ôºö' + e.message;
      } finally {
        setCompletionsLoading(false);
      }
    }

    function normalizeHistory(history) {
      if (!Array.isArray(history)) return [];
      const out = [];
      for (const m of history) {
        const role = m?.role;
        if (role !== 'user' && role !== 'assistant' && role !== 'system' && role !== 'tool') continue;
        const attachments = Array.isArray(m?.attachments)
          ? m.attachments
            .filter(a => a && typeof a.url === 'string' && a.url.trim() && (a.type === 'file' || a.type === 'image_url' || a.type === 'text_file' || a.type === 'file_url'))
            .map(a => {
              const t = String(a.type);
              if (t === 'file') {
                return { type: 'file', url: String(a.url), name: (a.name == null ? '' : String(a.name)), isImage: a.isImage === true };
              }
              if (t === 'image_url') {
                return { type: 'file', url: String(a.url), name: (a.name == null ? '' : String(a.name)), isImage: true };
              }
              return { type: 'file', url: String(a.url), name: (a.name == null ? '' : String(a.name)), isImage: false };
            })
          : [];
        out.push({
          id: m?.id || uid(),
          role,
          content: (m?.content == null ? '' : String(m.content)),
          attachments,
          reasoning: (typeof m?.reasoning === 'string' ? m.reasoning : ''),
          hidden: m?.hidden === true,
          uiContent: (typeof m?.uiContent === 'string' ? m.uiContent : undefined),
          tool_call_id: (typeof m?.tool_call_id === 'string' ? m.tool_call_id : undefined),
          ts: typeof m?.ts === 'number' ? m.ts : Date.now(),
          order: typeof m?.order === 'number' ? m.order : undefined,
          isSystemLog: m?.isSystemLog === true
        });
      }
      return out;
    }

    function normalizeSystemLogs(history) {
      return normalizeHistory(history).filter(m => m.role === 'system').map(m => {
        m.isSystemLog = true;
        return m;
      });
    }

    function getRenderableMessages() {
      const all = [];
      for (const m of state.messages) {
        if (m && m.hidden) continue;
        all.push(m);
      }
      for (const m of state.systemLogs) {
        if (m && m.hidden) continue;
        all.push(m);
      }
      all.sort((a, b) => {
        const ao = Number.isFinite(a?.order) ? a.order : (Number.isFinite(a?.ts) ? a.ts : 0);
        const bo = Number.isFinite(b?.order) ? b.order : (Number.isFinite(b?.ts) ? b.ts : 0);
        if (ao !== bo) return ao - bo;
        const at = Number.isFinite(a?.ts) ? a.ts : 0;
        const bt = Number.isFinite(b?.ts) ? b.ts : 0;
        return at - bt;
      });
      return all;
    }

    function syncMessageSequence() {
      let max = 0;
      for (const m of state.messages.concat(state.systemLogs)) {
        const v = Number.isFinite(m?.order) ? m.order : (Number.isFinite(m?.ts) ? m.ts : 0);
        if (v > max) max = v;
      }
      state.msgSeq = max;
    }

    async function loadCompletion(id) {
      const data = await fetchJson('/api/chat/completion/get?name=' + encodeURIComponent(id), { method: 'GET' });
      const s = data?.data || {};
      els.titleInput.value = s.title || '';
      els.systemPrompt.value = lzDecompressIfNeeded(s.systemPrompt || '');
      els.rolePrompt.value = lzDecompressIfNeeded(s.prompt || '');
      state.currentCreatedAt = Number(s.createdAt || 0);
      {
        const timingsText = lzDecompressIfNeeded(s.timingsJson || '');
        let parsed = null;
        try { parsed = timingsText ? JSON.parse(timingsText) : null; } catch (e) { parsed = null; }
        if (Array.isArray(parsed)) state.timingsLog = parsed;
        else state.timingsLog = [];
      }

      let ext = {};
      const paramsJsonText = lzDecompressIfNeeded(s.paramsJson || '');
      try { ext = paramsJsonText ? JSON.parse(paramsJsonText) : {}; } catch (e) { ext = {}; }
      if (ext?.model) els.modelSelect.value = ext.model;
      els.userName.value = (ext?.userName == null ? '' : String(ext.userName));
      els.userPrefix.value = (ext?.userPrefix == null ? '' : String(ext.userPrefix));
      els.userSuffix.value = (ext?.userSuffix == null ? '' : String(ext.userSuffix));
      els.assistantPrefix.value = (ext?.assistantPrefix == null ? '' : String(ext.assistantPrefix));
      els.assistantSuffix.value = (ext?.assistantSuffix == null ? '' : String(ext.assistantSuffix));
      if (ext?.params?.max_tokens != null) els.maxTokens.value = String(ext.params.max_tokens);
      if (ext?.params?.temperature != null) els.temperature.value = String(ext.params.temperature);
      if (ext?.params?.top_p != null) els.topP.value = String(ext.params.top_p);
      els.minP.value = '';
      els.repeatPenalty.value = '';
      els.stopSequences.value = '';
      if (ext?.params?.min_p != null) els.minP.value = String(ext.params.min_p);
      if (ext?.params?.repeat_penalty != null) els.repeatPenalty.value = String(ext.params.repeat_penalty);
      const stopVal = ext?.params?.stop;
      if (Array.isArray(stopVal)) els.stopSequences.value = stopVal.map(s => String(s)).join('\n');
      else if (typeof stopVal === 'string') els.stopSequences.value = stopVal;
      if (ext?.enableThinking != null) els.thinkingToggle.checked = !!ext.enableThinking;
      else els.thinkingToggle.checked = true;
      if (ext?.enableWebSearch != null) els.webSearchToggle.checked = !!ext.enableWebSearch;
      else els.webSearchToggle.checked = false;

      if (Array.isArray(ext?.enabledMcpTools)) {
        state.enabledMcpTools = ext.enabledMcpTools.map(normalizeToolName).filter(Boolean);
      } else if (!Array.isArray(state.enabledMcpTools)) {
        state.enabledMcpTools = [];
      }
      if (state.mcpToolsData && els.mcpToolsList && els.mcpToolsList.childNodes && els.mcpToolsList.childNodes.length) {
        renderMcpTools(state.mcpToolsData);
      } else {
        updateMcpToolsStatus();
      }

      const loadedApiModel = (ext?.apiModel != null ? ext.apiModel : s.apiModel);
      if (loadedApiModel != null) {
        state.apiModel = Number(loadedApiModel) === 0 ? 0 : 1;
      }
      els.apiModelSelect.value = String(state.apiModel);

      const historyAll = normalizeHistory(ext?.history);
      const legacySystemLogs = historyAll.filter(m => m.role === 'system');
      state.messages = historyAll.filter(m => m.role !== 'system');
      state.systemLogs = normalizeSystemLogs((Array.isArray(ext?.systemLogs) && ext.systemLogs.length) ? ext.systemLogs : legacySystemLogs);
      syncMessageSequence();
      rerenderAll();
      if (els.avatarSettingPreview) applyAssistantAvatar(els.avatarSettingPreview);
      setSaveHint('');
    }

    async function runCompletion() {
      const userText = (els.promptInput.value || '').trim();
      if (!userText) {
        setStatus('ËØ∑ËæìÂÖ•Ê∂àÊÅØ');
        return;
      }
      if (!state.currentCompletionId) {
        await loadCompletions(true);
        if (!state.currentCompletionId) return;
      }

      els.promptInput.value = '';
      const userMsg = addMessage('user', userText);
      if (state.pendingAttachment && state.pendingAttachment.file) {
        state.pendingAttachment.messageId = userMsg.id;
      }
      scheduleSave('ÂèëÈÄÅ');
      if (!!els.streamToggle.checked) {
        await generateIntoMessage(state.messages, null);
      } else {
        const assistantMsg = addMessage('assistant', '');
        await generateIntoMessage(state.messages, assistantMsg.id);
      }
    }

    async function kvCacheAction(action) {
      const a = String(action || '').toLowerCase();
      const verb = a === 'load' ? 'Âä†ËΩΩ' : '‰øùÂ≠ò';
      try {
        const modelId = els.modelSelect.value;
        if (!modelId) {
          setStatus('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã');
          return;
        }
        const slotId = 0;
        setStatus(verb + 'KVÁºìÂ≠ò‰∏≠...');
        const response = await fetchJson('/api/models/slots/' + (a === 'load' ? 'load' : 'save'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modelId: modelId,
            slotId: slotId
          })
        });

        if (response.success) {
          setStatus('KVÁºìÂ≠ò' + verb + 'ÊàêÂäü');
        } else {
          setStatus('KVÁºìÂ≠ò' + verb + 'Â§±Ë¥•: ' + (response.message || 'Êú™Áü•ÈîôËØØ'));
        }
      } catch (e) {
        setStatus('KVÁºìÂ≠ò' + verb + 'Â§±Ë¥•: ' + e.message);
      }
    }

    function closeSettingsPanel() {
      els.settingsPanel.classList.remove('open');
      els.sysPromptBox.classList.remove('open');
      els.rolePromptBox.classList.remove('open');
      document.documentElement.style.overflow = '';
    }

    function toggleSettingsPanel() {
      const open = !els.settingsPanel.classList.contains('open');
      els.settingsPanel.classList.toggle('open', open);
      els.sysPromptBox.classList.toggle('open', open);
      els.rolePromptBox.classList.toggle('open', open);
      document.documentElement.style.overflow = open ? 'hidden' : '';
      if (open && els.avatarSettingPreview) applyAssistantAvatar(els.avatarSettingPreview);
      if (open) refreshMcpTools();
    }

    function bindEvents() {
      els.sessionsToggle.addEventListener('click', () => {
        openDrawer();
        loadCompletions(false);
      });
      els.drawerClose.addEventListener('click', closeDrawer);
      els.backdrop.addEventListener('click', closeDrawer);

      els.modelRowToggle.addEventListener('click', () => {
        const open = els.modelRow.classList.toggle('visible');
        els.modelRowToggle.textContent = open ? '√ó' : '‚ò∞';
        els.modelRowToggle.title = open ? 'ÈöêËóèÊ®°ÂûãÊ†è' : 'ÊòæÁ§∫Ê®°ÂûãÊ†è';
        els.modelRowToggle.setAttribute('aria-label', open ? 'ÈöêËóèÊ®°ÂûãÊ†è' : 'ÊòæÁ§∫Ê®°ÂûãÊ†è');
        els.modelRowToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      });

      els.refreshModels.addEventListener('click', () => loadModels());

      els.attachBtn.addEventListener('click', () => {
        if (els.attachInput) els.attachInput.click();
      });
      els.attachInput.addEventListener('change', (e) => {
        const file = e && e.target && e.target.files ? e.target.files[0] : null;
        setAttachment(file);
      });
      els.attachClear.addEventListener('click', () => clearAttachment());
      
      els.chatList.addEventListener('click', (e) => {
        const avatar = e && e.target ? e.target.closest('.avatar.clickable') : null;
        if (!avatar) return;
        if (!state.currentCompletionId) return;
        viewAvatar(state.currentCompletionId);
      });

      els.sendBtn.addEventListener('click', () => runCompletion());
      els.stopBtn.addEventListener('click', () => {
        if (state.abortController) state.abortController.abort();
      });

      els.clearChat.addEventListener('click', () => {
        if (!confirm('Á°ÆËÆ§Ê∏ÖÁ©∫ÂΩìÂâçËßíËâ≤ÁöÑÂØπËØùÂÜÖÂÆπÔºü')) return;
        state.messages = [];
        rerenderAll();
        scheduleSave('Ê∏ÖÁ©∫ÂØπËØù');
      });

      els.toggleSettings.addEventListener('click', () => {
        toggleSettingsPanel();
      });
      els.closeSettings.addEventListener('click', () => {
        closeSettingsPanel();
      });

      if (els.refreshMcpTools) {
        els.refreshMcpTools.addEventListener('click', () => refreshMcpTools());
      }
      
      if (els.avatarSettingPreview) {
        els.avatarSettingPreview.addEventListener('click', () => {
          if (!state.currentCompletionId) return;
          viewAvatar(state.currentCompletionId);
        });
      }
      if (els.avatarSettingUpload) {
        els.avatarSettingUpload.addEventListener('click', () => {
          if (!state.currentCompletionId) return;
          getAvatarUploadInput().click();
        });
      }

      els.newSessionBtn.addEventListener('click', () => createCompletion());
      els.reloadSessionsBtn.addEventListener('click', () => loadCompletions(false));

      els.sessionsList.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action="delete"]');
        const item = e.target.closest('.session-item');
        const id = item?.dataset?.id;
        if (btn && id) {
          e.stopPropagation();
          deleteCompletion(id);
          return;
        }
        if (id) switchCompletion(id);
      });

      els.titleInput.addEventListener('input', () => {
        refreshCompletionTitleInMessages();
        scheduleSave('Ê†áÈ¢ò');
      });
      els.modelSelect.addEventListener('change', () => scheduleSave('Ê®°Âûã'));
      els.apiModelSelect.addEventListener('change', () => {
        state.apiModel = Number(els.apiModelSelect.value) === 0 ? 0 : 1;
        scheduleSave('Á´ØÁÇπ');
      });
      els.systemPrompt.addEventListener('input', () => scheduleSave('Á≥ªÁªüÊèèËø∞'));
      els.rolePrompt.addEventListener('input', () => scheduleSave('ËßíËâ≤ËÆæÂÆö'));
      els.userName.addEventListener('input', () => scheduleSave('Áî®Êà∑Âêç'));
      els.userPrefix.addEventListener('input', () => scheduleSave('Áî®Êà∑ÂâçÁºÄ'));
      els.userSuffix.addEventListener('input', () => scheduleSave('Áî®Êà∑ÂêéÁºÄ'));
      els.assistantPrefix.addEventListener('input', () => scheduleSave('Âä©ÊâãÂâçÁºÄ'));
      els.assistantSuffix.addEventListener('input', () => scheduleSave('Âä©ÊâãÂêéÁºÄ'));
      els.maxTokens.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.temperature.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.topP.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.minP.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.repeatPenalty.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.stopSequences.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.thinkingToggle.addEventListener('change', () => scheduleSave('ÊÄùËÄÉÂºÄÂÖ≥'));
      els.webSearchToggle.addEventListener('change', () => scheduleSave('ËÅîÁΩëÊêúÁ¥¢ÂºÄÂÖ≥'));

      els.kvCacheToggle.addEventListener('click', openKVCacheModal);
      els.kvCacheClose.addEventListener('click', closeKVCacheModal);
      els.kvCacheCancel.addEventListener('click', closeKVCacheModal);
      els.kvCacheModal.addEventListener('click', (e) => {
        if (e.target === els.kvCacheModal) closeKVCacheModal();
      });
      els.saveKV.addEventListener('click', () => kvCacheAction('save'));
      els.loadKV.addEventListener('click', () => kvCacheAction('load'));

      els.editModal.addEventListener('click', (e) => {
        if (e.target === els.editModal) closeEditModal();
      });
      els.editClose.addEventListener('click', closeEditModal);
      els.editCancel.addEventListener('click', closeEditModal);
      els.editSave.addEventListener('click', saveEditModal);

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (els.editModal.classList.contains('show')) {
            closeEditModal();
            return;
          }
          if (els.kvCacheModal.classList.contains('show')) {
            closeKVCacheModal();
            return;
          }
          if (els.settingsPanel.classList.contains('open')) {
            closeSettingsPanel();
            return;
          }
          if (els.drawer.classList.contains('open')) {
            closeDrawer();
            return;
          }
        }
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          if (els.editModal.classList.contains('show')) {
            saveEditModal();
            return;
          }
          runCompletion();
        }
      });
    }

    async function init() {
      bindEvents();
      renderAttachment();
      els.apiModelSelect.value = String(state.apiModel);
      await loadModels();
      await loadCompletions(true);
    }

    init();
  </script>
</body>

</html>
