<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Easy Chat</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: rgba(17, 24, 39, 0.72);
      --panel-2: rgba(15, 23, 42, 0.72);
      --text: #e5e7eb;
      --muted: #94a3b8;
      --border: rgba(148, 163, 184, 0.18);
      --primary: #10a37f;
      --danger: #ef4444;
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
      --bubble-user: rgba(59, 130, 246, 0.18);
      --bubble-ai: rgba(16, 163, 127, 0.14);
      --bubble-sys: rgba(148, 163, 184, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      color: var(--text);
      font-family: var(--sans);
      background:
        radial-gradient(1200px 900px at 10% 15%, rgba(16, 163, 127, 0.14), transparent 55%),
        radial-gradient(1000px 800px at 85% 12%, rgba(59, 130, 246, 0.14), transparent 55%),
        radial-gradient(900px 700px at 60% 90%, rgba(168, 85, 247, 0.10), transparent 55%),
        var(--bg);
      overflow: hidden;
    }

    button,
    input,
    select,
    textarea {
      font-family: inherit;
      color: var(--text);
    }

    .app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(17, 24, 39, 0.72);
      backdrop-filter: blur(12px);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(2, 6, 23, 0.35);
    }

    .pill label {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 52vw;
    }

    .btn {
      border: 1px solid var(--border);
      background: rgba(2, 6, 23, 0.35);
      border-radius: 12px;
      padding: 8px 12px;
      cursor: pointer;
      transition: transform 0.06s ease, background 0.16s ease, border-color 0.16s ease;
      min-height: 36px;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .btn.primary {
      border-color: rgba(16, 163, 127, 0.5);
      background: rgba(16, 163, 127, 0.18);
    }

    .btn.danger {
      border-color: rgba(239, 68, 68, 0.5);
      background: rgba(239, 68, 68, 0.16);
    }

    .btn.ghost {
      background: transparent;
    }

    .main {
      flex: 1;
      display: flex;
      justify-content: center;
      padding: 14px;
      overflow: hidden;
    }

    .chat-shell {
      width: min(980px, 100%);
      height: 100%;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .chat-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel-2);
    }

    .chat-title {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
      flex: 1;
    }

    .title-input {
      width: 100%;
      min-width: 200px;
      background: rgba(2, 6, 23, 0.35);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
    }

    .title-input:focus,
    .composer textarea:focus,
    .composer input:focus,
    .composer select:focus {
      border-color: rgba(16, 163, 127, 0.55);
      box-shadow: 0 0 0 4px rgba(16, 163, 127, 0.14);
    }

    .chat-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .chat-list {
      flex: 1;
      overflow: auto;
      padding: 14px 12px;
      background:
        radial-gradient(700px 450px at 40% 10%, rgba(148, 163, 184, 0.08), transparent 65%),
        rgba(2, 6, 23, 0.16);
    }

    .msg {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 0;
      padding: 10px 0;
      align-items: stretch;
      border-bottom: 1px solid var(--border);
    }

    .msg-head {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.82), rgba(2, 6, 23, 0.58));
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.22), inset 0 1px 0 rgba(148, 163, 184, 0.10);
    }

    .msg-head .meta {
      flex: 1 1 auto;
      min-width: 0;
    }

    .avatar {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(2, 6, 23, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: var(--muted);
      flex: 0 0 auto;
      user-select: none;
    }

    .bubble {
      width: 100%;
      flex: 0 0 auto;
      min-width: 0;
      max-width: 100%;
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
      overflow: visible;
    }

    .msg.user .bubble,
    .msg.assistant .bubble,
    .msg.system .bubble {
      border-radius: 12px;
      padding: 10px 12px;
    }

    .msg.user .bubble {
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.18), rgba(59, 130, 246, 0.00) 70%);
    }

    .msg.assistant .bubble {
      background: linear-gradient(90deg, rgba(16, 163, 127, 0.16), rgba(16, 163, 127, 0.00) 70%);
    }

    .msg.system .bubble {
      background: linear-gradient(90deg, rgba(148, 163, 184, 0.14), rgba(148, 163, 184, 0.00) 70%);
    }

    .meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 0;
      color: var(--muted);
      font-size: 12px;
    }

    .meta-left {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1 1 auto;
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
    }

    .meta-right {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      min-width: 0;
      flex: 0 0 auto;
      font-size: 12px;
    }

    .msg-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    .msg-btn {
      border: 1px solid var(--border);
      background: rgba(2, 6, 23, 0.28);
      border-radius: 10px;
      padding: 4px 8px;
      cursor: pointer;
      transition: transform 0.06s ease, background 0.16s ease, border-color 0.16s ease;
      min-height: 24px;
      font-size: 12px;
      line-height: 1.1;
      color: var(--text);
    }

    .msg-btn:active {
      transform: translateY(1px);
    }

    .msg-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .msg-btn.ghost {
      background: transparent;
    }

    .msg-btn.danger {
      border-color: rgba(239, 68, 68, 0.55);
      background: rgba(239, 68, 68, 0.12);
    }

    .content {
      white-space: normal;
      word-break: break-word;
      line-height: 1.55;
      font-size: 14px;
      text-align: left;
    }

    .content.plain {
      white-space: pre-wrap;
    }

    .content p {
      margin: 0 0 10px 0;
    }

    .content p:last-child {
      margin-bottom: 0;
    }

    .content ul,
    .content ol {
      margin: 6px 0 10px 1.25em;
      padding: 0;
    }

    .content li {
      margin: 2px 0;
    }

    .content blockquote {
      margin: 8px 0;
      padding: 6px 12px;
      border-left: 3px solid var(--border);
      border-radius: 10px;
      background: rgba(2, 6, 23, 0.18);
      color: var(--muted);
    }

    .content pre {
      margin: 8px 0;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(2, 6, 23, 0.28);
      overflow-x: auto;
    }

    .content code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
    }

    .content :not(pre)>code {
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(2, 6, 23, 0.22);
    }

    .content a {
      color: rgba(96, 165, 250, 0.95);
      text-decoration: underline;
      word-break: break-word;
    }

    .content table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 13px;
    }

    .content th,
    .content td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }

    .content hr {
      border: 0;
      border-top: 1px solid var(--border);
      margin: 10px 0;
    }

    .content img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .reasoning {
      margin: 0 0 10px 0;
      border: 1px dashed rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 6px 8px;
      background: rgba(2, 6, 23, 0.18);
    }

    .reasoning>summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .reasoning pre {
      margin: 8px 0 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.5;
      color: rgba(226, 232, 240, 0.92);
    }

    .composer {
      border-top: 1px solid var(--border);
      background: var(--panel-2);
      padding: 8px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .model-row {
      display: none;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .model-row.visible {
      display: flex;
    }

    .composer select,
    .composer input[type="number"] {
      background: rgba(2, 6, 23, 0.35);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
      min-height: 36px;
    }

    .composer textarea {
      width: 100%;
      resize: vertical;
      min-height: 64px;
      max-height: 240px;
      background: rgba(2, 6, 23, 0.35);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      outline: none;
      line-height: 1.5;
      font-size: 14px;
    }

    .prompt-row {
      display: flex;
      align-items: flex-end;
      gap: 10px;
    }

    .prompt-row textarea {
      flex: 1;
      min-width: 0;
    }

    .prompt-actions {
      display: flex;
      align-items: flex-end;
      gap: 10px;
      flex: 0 0 auto;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .toolbar .spacer {
      flex: 1;
    }

    .attach-info {
      display: none;
      align-items: center;
      gap: 10px;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(2, 6, 23, 0.30);
      max-width: 55%;
    }

    .attach-info .name {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: rgba(226, 232, 240, 0.92);
      font-size: 13px;
    }

    .attach-info .clear {
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .attachments {
      margin-top: 10px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .attachment-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(2, 6, 23, 0.22);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .attachment-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .attachment-name {
      font-size: 13px;
      color: rgba(226, 232, 240, 0.92);
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .attachment-link {
      color: var(--primary);
      text-decoration: none;
      font-size: 13px;
      flex: 0 0 auto;
    }

    .attachment-link:hover {
      text-decoration: underline;
    }

    .attachment-preview {
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(2, 6, 23, 0.18);
      overflow: hidden;
    }

    .attachment-preview img {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .attachment-preview pre {
      margin: 0;
      padding: 10px 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12.5px;
      line-height: 1.5;
      color: rgba(226, 232, 240, 0.92);
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(2, 6, 23, 0.30);
      user-select: none;
      cursor: pointer;
      min-height: 36px;
    }

    .toggle input {
      accent-color: var(--primary);
    }

    .settings {
      display: none;
    }

    .settings.open {
      display: flex;
      position: fixed;
      inset: 0;
      z-index: 60;
      padding: 14px;
      background: rgba(15, 23, 42, 0.92);
      backdrop-filter: blur(12px);
      overflow: auto;
      flex-direction: column;
      gap: 12px;
    }

    .settings-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(2, 6, 23, 0.30);
    }

    .settings-head .settings-title {
      font-weight: 800;
    }

    .settings-body {
      display: grid;
      grid-template-columns: minmax(220px, 320px) minmax(320px, 1fr) minmax(320px, 1fr);
      grid-template-areas: "left center right";
      gap: 12px;
      align-items: start;
    }

    .settings-left {
      grid-area: left;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .settings-center {
      grid-area: center;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .settings-right {
      grid-area: right;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .setting {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(2, 6, 23, 0.30);
    }

    .setting label {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }

    .setting input {
      width: 100%;
      min-width: 0;
      background: transparent;
      border: none;
      outline: none;
      font-size: 13px;
      line-height: 1.2;
    }

    .setting input::placeholder {
      color: rgba(148, 163, 184, 0.75);
    }

    .sys-prompt {
      display: none;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(2, 6, 23, 0.30);
    }

    .sys-prompt.open {
      display: flex;
    }

    .sys-prompt textarea {
      min-height: 220px;
      max-height: 62vh;
    }

    .sys-prompt .sys-title {
      color: var(--muted);
      font-size: 12px;
    }

    .long-setting {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(2, 6, 23, 0.30);
    }

    .long-setting label {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }

    .long-setting textarea {
      width: 100%;
      resize: vertical;
      min-height: 110px;
      max-height: 40vh;
      background: transparent;
      border: none;
      outline: none;
      line-height: 1.5;
      font-size: 14px;
    }

    .long-setting textarea::placeholder {
      color: rgba(148, 163, 184, 0.75);
    }

    .drawer {
      position: fixed;
      top: 0;
      right: 0;
      height: 100%;
      width: 360px;
      max-width: calc(100vw - 24px);
      transform: translateX(105%);
      transition: transform 0.22s ease;
      border-left: 1px solid var(--border);
      background: rgba(17, 24, 39, 0.86);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      z-index: 50;
    }

    .drawer.open {
      transform: translateX(0);
    }

    .backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.50);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease;
      z-index: 40;
    }

    .backdrop.show {
      opacity: 1;
      pointer-events: auto;
    }

    .drawer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.72);
    }

    .drawer-title {
      font-weight: 800;
    }

    .drawer-actions {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .sessions {
      list-style: none;
      margin: 0;
      padding: 10px 10px;
      overflow: auto;
      flex: 1;
    }

    .session-item {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      background: rgba(2, 6, 23, 0.30);
      transition: border-color 0.16s ease, background 0.16s ease;
    }

    .session-item:hover {
      background: rgba(2, 6, 23, 0.42);
    }

    .session-item.active {
      border-color: rgba(16, 163, 127, 0.65);
      background: rgba(16, 163, 127, 0.12);
    }

    .session-meta {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .session-title {
      font-weight: 700;
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .session-sub {
      font-size: 12px;
      color: var(--muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .icon-btn {
      width: 34px;
      height: 34px;
      padding: 0;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      font-size: 18px;
    }

    .modal-wrap {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
      background: rgba(0, 0, 0, 0.55);
      z-index: 80;
    }

    .modal-wrap.show {
      display: flex;
    }

    .modal-card {
      width: min(760px, calc(100vw - 28px));
      max-height: calc(100vh - 28px);
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(17, 24, 39, 0.92);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.72);
    }

    .modal-title {
      font-weight: 800;
    }

    .modal-body {
      padding: 12px 14px;
      overflow: auto;
    }

    .modal-body textarea {
      width: 100%;
      resize: vertical;
      min-height: 180px;
      max-height: 52vh;
      background: rgba(2, 6, 23, 0.35);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      outline: none;
      line-height: 1.5;
      font-size: 14px;
    }

    #editModal .modal-body textarea {
      min-height: 340px;
      max-height: 72vh;
    }

    .modal-actions {
      padding: 12px 14px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      background: rgba(15, 23, 42, 0.60);
    }

    @media (max-width: 680px) {
      .bubble {
        max-width: 100%;
      }

      .model-row.visible {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        align-items: center;
      }

      .model-row.visible .pill {
        grid-column: 1 / -1;
        flex-wrap: wrap;
      }

      .model-row.visible .pill select {
        flex: 1;
        min-width: 0;
      }

      .model-row.visible .toggle,
      .model-row.visible .btn {
        width: 100%;
      }

      .settings-body {
        grid-template-columns: 1fr;
        grid-template-areas: "left" "center" "right";
      }
    }

    @media (max-width: 980px) {
      .settings-body {
        grid-template-columns: 1fr;
        grid-template-areas: "left" "center" "right";
      }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="main">
      <div class="chat-shell">
        <div class="chat-top">
          <div class="chat-title">
            <input id="titleInput" class="title-input" type="text" placeholder="ËßíËâ≤ÂêçÁß∞ÔºàËá™Âä®‰øùÂ≠òÔºâ" />
          </div>
          <div class="chat-actions">
            <button id="sessionsToggle" class="btn ghost" type="button">ËßíËâ≤ÂàóË°®</button>
          </div>
        </div>

        <div id="chatList" class="chat-list"></div>

        <div class="composer">
          <div class="model-row">
            <div class="pill">
              <label for="modelSelect">Ê®°Âûã</label>
              <select id="modelSelect"></select>
              <button id="refreshModels" class="btn" type="button">Âà∑Êñ∞</button>
            </div>
            <div class="toggle">
              <input id="autoScroll" type="checkbox" checked />
              <label for="autoScroll" class="hint">Ëá™Âä®ÊªöÂä®</label>
            </div>
            <div class="toggle">
              <input id="streamToggle" type="checkbox" checked />
              <label for="streamToggle" class="hint">ÊµÅÂºè‰º†Ëæì</label>
            </div>
            <div class="toggle">
              <input id="thinkingToggle" type="checkbox" checked />
              <label for="thinkingToggle" class="hint">ÂºÄÂêØÊÄùËÄÉ</label>
            </div>
            <button id="toggleSettings" class="btn" type="button">ËÆæÁΩÆ</button>
            <button id="clearChat" class="btn" type="button">Ê∏ÖÁ©∫</button>
            <button id="kvCacheToggle" class="btn icon-btn ghost" type="button" title="KVÁºìÂ≠òÁÆ°ÁêÜ">üíæ</button>
          </div>

          <div id="settingsPanel" class="settings">
            <div class="settings-head">
              <div class="settings-title">ËÆæÁΩÆ</div>
              <button id="closeSettings" class="btn" type="button">ÂÖ≥Èó≠</button>
            </div>

            <div class="settings-body">
              <div class="settings-left">
                <div class="setting">
                  <label for="userName">Áî®Êà∑ÂêçÂ≠ó</label>
                  <input id="userName" type="text" placeholder="‰æãÂ¶ÇÔºöÊàë" />
                </div>
                <div class="setting">
                  <label for="apiModelSelect">API Á´ØÁÇπ</label>
                  <select id="apiModelSelect">
                    <option value="1">/v1/chat/completions</option>
                    <option value="0">/v1/completions</option>
                  </select>
                </div>
                <div class="setting">
                  <label for="maxTokens">max_tokens</label>
                  <input id="maxTokens" type="number" value="512" min="1" max="32768" />
                </div>
                <div class="setting">
                  <label for="temperature">temperature</label>
                  <input id="temperature" type="number" value="0.7" step="0.1" min="0" max="2" />
                </div>
                <div class="setting">
                  <label for="topP">top_p</label>
                  <input id="topP" type="number" value="1" step="0.05" min="0" max="1" />
                </div>
                <div class="setting">
                  <label for="minP">min_p</label>
                  <input id="minP" type="number" step="0.01" min="0" max="1" value="0.05" />
                </div>
                <div class="setting">
                  <label for="repeatPenalty">repeat_penalty</label>
                  <input id="repeatPenalty" type="number" step="0.05" min="0" max="10" value="1.0" />
                </div>
                <div class="long-setting">
                  <label for="stopSequences">stop</label>
                  <textarea id="stopSequences" placeholder="‰∏ÄË°å‰∏Ä‰∏™ stop Â∫èÂàóÔºõÁïôÁ©∫Ë°®Á§∫‰ΩøÁî®ÂÜÖÁΩÆÈªòËÆ§ stop"></textarea>
                </div>
              </div>

              <div class="settings-center">
                <div id="sysPromptBox" class="sys-prompt">
                  <div class="sys-title">Á≥ªÁªüÊèèËø∞ÔºàÂ∞ÜÂä†ÂÖ•Âà∞ÂØπËØùÂºÄÂ§¥Ôºâ</div>
                  <textarea id="systemPrompt" placeholder="‰æãÂ¶ÇÔºö‰Ω†ÊòØ‰∏Ä‰∏™‰∏•Ë∞®ÁöÑÂÜô‰ΩúÂä©ÊâãÔºåËæìÂá∫‰∏≠ÊñáÔºåÁªìÊûÑÊ∏ÖÊô∞‚Ä¶"></textarea>
                </div>

                <div id="rolePromptBox" class="sys-prompt">
                  <div class="sys-title">ËßíËâ≤ËÆæÂÆöÔºàÂ∞ÜÂä†ÂÖ•Âà∞ÂØπËØùÂºÄÂ§¥Ôºâ</div>
                  <textarea id="rolePrompt" placeholder="‰æãÂ¶ÇÔºö‰Ω†Âè´XXÔºå‰Ω†ÁöÑÊÄßÊ†º/ÁõÆÊ†á/Âè£Áôñ/‰∏ñÁïåËßÇ‚Ä¶"></textarea>
                </div>
              </div>

              <div class="settings-right">
                <div class="long-setting">
                  <label for="userPrefix">Áî®Êà∑Ê∂àÊÅØÂâçÁºÄ</label>
                  <textarea id="userPrefix" placeholder="ÂèØÈÄâ"></textarea>
                </div>
                <div class="long-setting">
                  <label for="userSuffix">Áî®Êà∑Ê∂àÊÅØÂêéÁºÄ</label>
                  <textarea id="userSuffix" placeholder="ÂèØÈÄâ"></textarea>
                </div>
                <div class="long-setting">
                  <label for="assistantPrefix">Âä©ÊâãÊ∂àÊÅØÂâçÁºÄ</label>
                  <textarea id="assistantPrefix" placeholder="ÂèØÈÄâ"></textarea>
                </div>
                <div class="long-setting">
                  <label for="assistantSuffix">Âä©ÊâãÊ∂àÊÅØÂêéÁºÄ</label>
                  <textarea id="assistantSuffix" placeholder="ÂèØÈÄâ"></textarea>
                </div>
              </div>
            </div>
          </div>

          <div class="prompt-row">
            <button id="modelRowToggle" style="width: 48px; height: 100%" class="btn icon-btn ghost" type="button" title="ÊòæÁ§∫Ê®°ÂûãÊ†è" aria-label="ÊòæÁ§∫Ê®°ÂûãÊ†è" aria-expanded="false">‚ò∞</button>
            <textarea id="promptInput" placeholder="ËæìÂÖ•Ê∂àÊÅØ‚Ä¶ÔºàCtrl+Enter ÂèëÈÄÅÔºâ"></textarea>
            <div class="prompt-actions">
              <button id="attachBtn" class="btn" type="button">ÈôÑ‰ª∂</button>
              <button id="sendBtn" class="btn primary" type="button">ÂèëÈÄÅ</button>
              <button id="stopBtn" class="btn danger" type="button" disabled>ÂÅúÊ≠¢</button>
            </div>
            <input id="attachInput" type="file" style="display:none" />
          </div>

          <div class="toolbar">
            <div class="hint" id="saveHint"></div>
            <div id="attachInfo" class="attach-info" aria-live="polite">
              <span class="hint">Â∑≤ÈÄâÈôÑ‰ª∂</span>
              <span id="attachName" class="name"></span>
              <button id="attachClear" class="btn icon-btn clear" type="button" aria-label="Ê∏ÖÈô§ÈôÑ‰ª∂">√ó</button>
            </div>
            <div class="spacer"></div>
          </div>
        </div>
      </div>
    </div>

    <div id="drawerBackdrop" class="backdrop"></div>
    <aside id="sessionsDrawer" class="drawer" aria-hidden="true">
      <div class="drawer-header">
        <div class="drawer-title">ËßíËâ≤</div>
        <button id="drawerClose" class="btn icon-btn" type="button" aria-label="Close">√ó</button>
      </div>
      <div class="drawer-actions">
        <button id="newSessionBtn" class="btn primary" type="button">Êñ∞Âª∫ËßíËâ≤</button>
        <button id="reloadSessionsBtn" class="btn" type="button">Âà∑Êñ∞</button>
        <span class="hint" id="drawerHint"></span>
      </div>
      <ul id="sessionsList" class="sessions"></ul>
    </aside>

    <div id="editModal" class="modal-wrap" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="modal-title">ÁºñËæëÊ∞îÊ≥°</div>
          <button id="editClose" class="btn icon-btn" type="button" aria-label="Close">√ó</button>
        </div>
        <div class="modal-body">
          <textarea id="editTextarea" placeholder="ËæìÂÖ•Êñ∞ÁöÑÂÜÖÂÆπ‚Ä¶"></textarea>
        </div>
        <div class="modal-actions">
          <button id="editCancel" class="btn" type="button">ÂèñÊ∂à</button>
          <button id="editSave" class="btn primary" type="button">‰øùÂ≠ò</button>
        </div>
      </div>
    </div>

    <div id="kvCacheModal" class="modal-wrap" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-head">
          <div class="modal-title">KVÁºìÂ≠òÁÆ°ÁêÜ</div>
          <button id="kvCacheClose" class="btn icon-btn" type="button" aria-label="Close">√ó</button>
        </div>
        <div class="modal-body">
          <p style="color: var(--muted); font-size: 14px; margin: 0 0 16px 0;">ÁÆ°ÁêÜÂΩìÂâçÊ®°ÂûãÁöÑKVÁºìÂ≠òÔºåÂèØ‰ª•‰øùÂ≠òÊàñÂä†ËΩΩÁºìÂ≠ò‰ª•Âä†Âø´Êé®ÁêÜÈÄüÂ∫¶„ÄÇ</p>
          <div style="display: flex; gap: 12px; justify-content: center;">
            <button id="saveKV" class="btn" type="button" style="min-width: 120px;">‰øùÂ≠òKVÁºìÂ≠ò</button>
            <button id="loadKV" class="btn" type="button" style="min-width: 120px;">Âä†ËΩΩKVÁºìÂ≠ò</button>
          </div>
        </div>
        <div class="modal-actions">
          <button id="kvCacheCancel" class="btn" type="button">ÂÖ≥Èó≠</button>
        </div>
      </div>
    </div>
  </div>
  <script src="/js/lz-string.js"></script>
  <script src="/js/marked.min.js"></script>
  <script src="/js/highlight.min.js"></script>
  <script>
    // ‰ºöËØùÊäΩÂ±âÁõ∏ÂÖ≥ÂÖÉÁ¥†
    const els = {
      sessionsToggle: document.getElementById('sessionsToggle'),
      drawer: document.getElementById('sessionsDrawer'),
      backdrop: document.getElementById('drawerBackdrop'),
      drawerClose: document.getElementById('drawerClose'),
      sessionsList: document.getElementById('sessionsList'),
      newSessionBtn: document.getElementById('newSessionBtn'),
      reloadSessionsBtn: document.getElementById('reloadSessionsBtn'),
      drawerHint: document.getElementById('drawerHint'),

      titleInput: document.getElementById('titleInput'),
      chatList: document.getElementById('chatList'),
      promptInput: document.getElementById('promptInput'),
      modelRowToggle: document.getElementById('modelRowToggle'),
      modelRow: document.querySelector('.model-row'),

      modelSelect: document.getElementById('modelSelect'),
      refreshModels: document.getElementById('refreshModels'),

      attachBtn: document.getElementById('attachBtn'),
      attachInput: document.getElementById('attachInput'),
      attachInfo: document.getElementById('attachInfo'),
      attachName: document.getElementById('attachName'),
      attachClear: document.getElementById('attachClear'),

      sendBtn: document.getElementById('sendBtn'),
      stopBtn: document.getElementById('stopBtn'),
      clearChat: document.getElementById('clearChat'),

      toggleSettings: document.getElementById('toggleSettings'),
      settingsPanel: document.getElementById('settingsPanel'),
      closeSettings: document.getElementById('closeSettings'),
      sysPromptBox: document.getElementById('sysPromptBox'),
      systemPrompt: document.getElementById('systemPrompt'),
      rolePromptBox: document.getElementById('rolePromptBox'),
      rolePrompt: document.getElementById('rolePrompt'),

      maxTokens: document.getElementById('maxTokens'),
      temperature: document.getElementById('temperature'),
      topP: document.getElementById('topP'),
      minP: document.getElementById('minP'),
      repeatPenalty: document.getElementById('repeatPenalty'),
      stopSequences: document.getElementById('stopSequences'),
      userName: document.getElementById('userName'),
      userPrefix: document.getElementById('userPrefix'),
      userSuffix: document.getElementById('userSuffix'),
      assistantPrefix: document.getElementById('assistantPrefix'),
      assistantSuffix: document.getElementById('assistantSuffix'),
      apiModelSelect: document.getElementById('apiModelSelect'),

      autoScroll: document.getElementById('autoScroll'),
      streamToggle: document.getElementById('streamToggle'),
      thinkingToggle: document.getElementById('thinkingToggle'),
      saveHint: document.getElementById('saveHint'),

      kvCacheToggle: document.getElementById('kvCacheToggle'),
      kvCacheModal: document.getElementById('kvCacheModal'),
      kvCacheClose: document.getElementById('kvCacheClose'),
      kvCacheCancel: document.getElementById('kvCacheCancel'),
      saveKV: document.getElementById('saveKV'),
      loadKV: document.getElementById('loadKV'),

      editModal: document.getElementById('editModal'),
      editTextarea: document.getElementById('editTextarea'),
      editClose: document.getElementById('editClose'),
      editCancel: document.getElementById('editCancel'),
      editSave: document.getElementById('editSave')
    };
    // ‰ºöËØùÊäΩÂ±âÁä∂ÊÄÅ
    const state = {
      currentCompletionId: null,
      currentCreatedAt: 0,
      isLoadingCompletions: false,
      isLoadingModels: false,
      abortController: null,
      saveTimer: null,
      lastSavedAt: 0,
      messages: [],
      messageEls: new Map(),
      editingMessageId: null,
      // Áî®/v1/chat/completionËøòÊòØ/v1/completions
      // ÂÄº‰∏∫1Êó∂ÔºåÁî®/v1/chat/completion
      // ÂÄº‰∏∫0Êó∂ÔºåÁî®/v1/completions
      apiModel: 1,
      pendingAttachment: null
    };

    function uid() {
      if (window.crypto?.randomUUID) return crypto.randomUUID();
      return String(Date.now()) + '-' + String(Math.random()).slice(2);
    }

    function escapeHtml(text) {
      return String(text == null ? '' : text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function isSafeUrl(value) {
      const href = String(value == null ? '' : value).trim();
      if (!href) return false;
      if (href.startsWith('#')) return true;
      try {
        const u = new URL(href, window.location.href);
        const p = u.protocol;
        return p === 'http:' || p === 'https:' || p === 'mailto:' || p === 'tel:';
      } catch (e) {
        return false;
      }
    }

    function sanitizeMarkdownHtml(html) {
      const allowedTags = new Set([
        'div',
        'p', 'br', 'strong', 'em', 'del',
        'code', 'pre',
        'blockquote',
        'ul', 'ol', 'li',
        'a', 'hr',
        'table', 'thead', 'tbody', 'tr', 'th', 'td',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'img', 'span'
      ]);

      const allowedAttrsByTag = {
        a: new Set(['href', 'title', 'target', 'rel']),
        img: new Set(['src', 'alt', 'title']),
        th: new Set(['align']),
        td: new Set(['align']),
        code: new Set(['class']),
        pre: new Set(['class']),
        span: new Set(['class'])
      };

      const doc = new DOMParser().parseFromString('<div>' + String(html || '') + '</div>', 'text/html');
      const root = doc.body && doc.body.firstChild ? doc.body.firstChild : null;
      if (!root) return '';

      const walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null);
      const nodes = [];
      let n = walker.currentNode;
      while (n) {
        nodes.push(n);
        n = walker.nextNode();
      }

      for (const el of nodes) {
        const tag = (el.tagName || '').toLowerCase();
        if (!allowedTags.has(tag)) {
          const parent = el.parentNode;
          if (!parent) continue;
          while (el.firstChild) parent.insertBefore(el.firstChild, el);
          parent.removeChild(el);
          continue;
        }

        const allowedAttrs = allowedAttrsByTag[tag] || null;
        for (const attr of Array.from(el.attributes || [])) {
          const name = (attr.name || '').toLowerCase();
          if (!allowedAttrs || !allowedAttrs.has(name)) {
            el.removeAttribute(attr.name);
            continue;
          }
          if ((tag === 'a' && name === 'href') || (tag === 'img' && name === 'src')) {
            const v = el.getAttribute(attr.name) || '';
            if (!isSafeUrl(v)) el.removeAttribute(attr.name);
          }
        }

        if (tag === 'a') {
          el.setAttribute('rel', 'noopener noreferrer');
          if (!el.getAttribute('target')) el.setAttribute('target', '_blank');
        }
      }

      return root.innerHTML;
    }

    function markdownToSafeHtml(text) {
      const input = escapeHtml(text);
      if (!window.marked || typeof window.marked.parse !== 'function') return input;
      let raw = '';
      try {
        raw = window.marked.parse(input, { gfm: true, breaks: true, mangle: false, headerIds: false });
      } catch (e) {
        return input;
      }
      return sanitizeMarkdownHtml(raw);
    }

    let markdownRaf = 0;
    const pendingMarkdownRenders = new Map();

    function renderMessageContentNow(el, text) {
      if (!el) return;
      const t = (text == null ? '' : String(text));
      if (!window.marked || typeof window.marked.parse !== 'function') {
        el.classList.add('plain');
        el.textContent = t;
        return;
      }
      el.classList.remove('plain');
      el.innerHTML = markdownToSafeHtml(t);
      if (window.hljs && typeof window.hljs.highlightElement === 'function' && (t.includes('```') || t.includes('`'))) {
        const blocks = el.querySelectorAll('pre code');
        for (const b of blocks) window.hljs.highlightElement(b);
      }
    }

    function requestRenderMessageContent(el, text) {
      if (!el) return;
      pendingMarkdownRenders.set(el, text);
      if (markdownRaf) return;
      markdownRaf = requestAnimationFrame(() => {
        markdownRaf = 0;
        for (const [node, value] of pendingMarkdownRenders.entries()) {
          renderMessageContentNow(node, value);
        }
        pendingMarkdownRenders.clear();
      });
    }

    function setStatus(text) {
      void text;
    }

    function setSaveHint(text) {
      els.saveHint.textContent = text || '';
    }

    async function fetchJson(url, options) {
      const res = await fetch(url, options);
      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch (e) { }
      if (!res.ok) {
        const message = (json && (json.message || json.error?.message)) ? (json.message || json.error.message) : (text || ('HTTP ' + res.status));
        throw new Error(message);
      }
      return json;
    }

    function getFileExt(fileName) {
      const n = (fileName == null ? '' : String(fileName)).trim();
      const idx = n.lastIndexOf('.');
      if (idx < 0) return '';
      return n.slice(idx + 1).toLowerCase();
    }

    function isLikelyImageUrl(url) {
      const u = (url == null ? '' : String(url)).toLowerCase();
      const q = u.indexOf('?');
      const clean = q >= 0 ? u.slice(0, q) : u;
      return clean.endsWith('.png') || clean.endsWith('.jpg') || clean.endsWith('.jpeg') || clean.endsWith('.webp') || clean.endsWith('.gif') || clean.endsWith('.bmp') || clean.endsWith('.svg');
    }

    function isLikelyImageFile(file) {
      const type = (file && file.type) ? String(file.type).toLowerCase() : '';
      if (type.startsWith('image/')) return true;
      const ext = getFileExt(file && file.name ? file.name : '');
      return ['png', 'jpg', 'jpeg', 'webp', 'gif', 'bmp', 'svg'].includes(ext);
    }

    function isLikelyTextFile(file) {
      const type = (file && file.type) ? String(file.type).toLowerCase() : '';
      if (type.startsWith('text/')) return true;
      if (type === 'application/json') return true;
      const ext = getFileExt(file && file.name ? file.name : '');
      return ['txt', 'md', 'markdown', 'sql', 'ini', 'cfg', 'conf', 'json', 'yaml', 'yml', 'csv', 'log'].includes(ext);
    }

    async function readTextAttachment(file) {
      if (!file) return '';
      const maxBytes = 1024 * 512;
      if (typeof file.size === 'number' && file.size > maxBytes) {
        return '[ÈôÑ‰ª∂ÂÜÖÂÆπËøáÂ§ßÔºåÂ∑≤ÁúÅÁï•„ÄÇËØ∑‰ΩøÁî®‰∏ãËΩΩÈìæÊé•Êü•ÁúãÂÆåÊï¥ÂÜÖÂÆπ„ÄÇ]';
      }
      try {
        const t = await file.text();
        const s = (t == null ? '' : String(t));
        if (!s.trim()) return '[ÈôÑ‰ª∂‰∏∫Á©∫]';
        if (s.length > 200000) return s.slice(0, 200000) + '\n[...Â∑≤Êà™Êñ≠...]';
        return s;
      } catch (e) {
        return '[ÈôÑ‰ª∂ËØªÂèñÂ§±Ë¥•]';
      }
    }

    function renderMessageAttachments(attachmentsEl, msg) {
      if (!attachmentsEl) return;
      attachmentsEl.innerHTML = '';
      const atts = Array.isArray(msg?.attachments) ? msg.attachments : [];
      if (!atts.length) {
        attachmentsEl.style.display = 'none';
        return;
      }
      attachmentsEl.style.display = 'flex';

      for (const a of atts) {
        if (!a || !a.url) continue;
        const item = document.createElement('div');
        item.className = 'attachment-item';

        const head = document.createElement('div');
        head.className = 'attachment-head';

        const nameEl = document.createElement('div');
        nameEl.className = 'attachment-name';
        nameEl.textContent = a.name ? String(a.name) : (a.type ? String(a.type) : 'file');

        const link = document.createElement('a');
        link.className = 'attachment-link';


        link.href = String(removeDomainFromUrl(a.url));
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = 'ÊâìÂºÄ';

        head.appendChild(nameEl);
        head.appendChild(link);
        item.appendChild(head);

        const isImage = a.isImage === true || isLikelyImageUrl(a.url) || ['png', 'jpg', 'jpeg', 'webp', 'gif', 'bmp', 'svg'].includes(getFileExt(a.name || ''));
        if (isImage) {
          const preview = document.createElement('div');
          preview.className = 'attachment-preview';
          const img = document.createElement('img');
          img.src = String(a.url);
          img.alt = a.name ? String(a.name) : 'image';
          preview.appendChild(img);
          item.appendChild(preview);
        }

        attachmentsEl.appendChild(item);
      }

      if (!attachmentsEl.childNodes || attachmentsEl.childNodes.length === 0) {
        attachmentsEl.style.display = 'none';
      }
    }

    function removeDomainFromUrl(url) {
      try {
        const urlObj = new URL(url);
        // ËøîÂõûË∑ØÂæÑ„ÄÅÊü•ËØ¢ÂèÇÊï∞ÂíåÂìàÂ∏åÈÉ®ÂàÜ
        return urlObj.pathname + urlObj.search + urlObj.hash;
      } catch (error) {
        // Â¶ÇÊûúURLÊó†ÊïàÔºåËøîÂõûÂéüÂßãÂ≠óÁ¨¶‰∏≤ÊàñÂ§ÑÁêÜÈîôËØØ
        console.error('Êó†ÊïàÁöÑURL:', error);
        return url;
      }
    }

    function renderAttachment() {
      const p = state.pendingAttachment;
      if (!p || !p.file) {
        els.attachInfo.style.display = 'none';
        els.attachName.textContent = '';
        return;
      }
      els.attachInfo.style.display = 'flex';
      els.attachName.textContent = p.originalName || p.file.name || '';
    }

    function clearAttachment() {
      state.pendingAttachment = null;
      if (els.attachInput) els.attachInput.value = '';
      renderAttachment();
    }

    function setAttachment(file) {
      if (!file) {
        clearAttachment();
        return;
      }
      state.pendingAttachment = { file, originalName: file.name || 'file', messageId: null, uploadedName: null };
      renderAttachment();
    }

    async function maybeUploadPendingAttachment() {
      const p = state.pendingAttachment;
      if (!p || !p.file || !p.messageId) return null;
      if (p.uploadedName) return p.uploadedName;

      const form = new FormData();
      form.append('file', p.file, p.originalName || p.file.name || 'file');
      const resp = await fetchJson('/api/chat/completion/file/upload', {
        method: 'POST',
        body: form,
        signal: state.abortController ? state.abortController.signal : undefined
      });
      const savedName = resp && resp.data && resp.data.name ? String(resp.data.name) : '';
      if (!savedName) throw new Error('‰∏ä‰º†Â§±Ë¥•ÔºöÁº∫Â∞ëËøîÂõûname');
      p.uploadedName = savedName;

      const m = state.messages.find(x => x.id === p.messageId);
      if (m) {
        const downloadPath = '/api/chat/completion/file/download?name=' + encodeURIComponent(savedName);
        const absoluteUrl = (typeof window !== 'undefined' && window.location && window.location.origin)
          ? (window.location.origin + downloadPath)
          : downloadPath;
        m.attachments = Array.isArray(m.attachments) ? m.attachments : [];
        const name = p.originalName || p.file.name || '';
        m.attachments.push({ type: 'file', url: absoluteUrl, name, isImage: isLikelyImageFile(p.file) });
        updateAttachments(m.id);
      }
      clearAttachment();
      return savedName;
    }

    //========================================================================================================================================
    // ÂéãÁº©/Ëß£Âéã JSON Â≠óÁ¨¶‰∏≤

    const LZ_PREFIX = 'lz:';

    function lzCompressIfNeeded(text) {
      if (text == null) return text;
      const s = String(text);
      if (!s) return s;
      if (s.startsWith(LZ_PREFIX)) return s;
      if (s.length < 256) return s;
      try {
        const compressed = window.LZString?.compressToEncodedURIComponent ? window.LZString.compressToEncodedURIComponent(s) : null;
        if (!compressed) return s;
        return LZ_PREFIX + compressed;
      } catch (e) {
        return s;
      }
    }

    function lzDecompressIfNeeded(text) {
      if (text == null) return text;
      const s = String(text);
      if (!s) return s;
      if (!s.startsWith(LZ_PREFIX)) return s;
      const payload = s.slice(LZ_PREFIX.length);
      try {
        const out = window.LZString?.decompressFromEncodedURIComponent ? window.LZString.decompressFromEncodedURIComponent(payload) : null;
        return out == null ? s : out;
      } catch (e) {
        return s;
      }
    }

    function formatTime(ts) {
      if (!ts) return '';
      try {
        return new Date(ts).toLocaleString();
      } catch (e) {
        return String(ts);
      }
    }

    //============================================================================================

    function normalizeSpeakerName(name, fallback) {
      const raw = (name == null ? '' : String(name)).trim();
      const cleaned = raw.replace(/[\r\n:]+/g, ' ').trim();
      return cleaned || fallback;
    }

    function getUserSpeakerName() {
      return normalizeSpeakerName(els.userName.value, 'User');
    }

    function getAssistantSpeakerName() {
      return normalizeSpeakerName(getCurrentCompletionTitle(), 'Assistant');
    }

    function getUserMessagePrefix() {
      return (els.userPrefix.value == null ? '' : String(els.userPrefix.value));
    }

    function getUserMessageSuffix() {
      return (els.userSuffix.value == null ? '' : String(els.userSuffix.value));
    }

    function getAssistantMessagePrefix() {
      return (els.assistantPrefix.value == null ? '' : String(els.assistantPrefix.value));
    }

    function getAssistantMessageSuffix() {
      return (els.assistantSuffix.value == null ? '' : String(els.assistantSuffix.value));
    }

    //============================================================================================

    function getCurrentCompletionTitle() {
      const name = (els.titleInput.value || '').trim();
      return name || 'ÈªòËÆ§ËßíËâ≤';
    }

    function refreshCompletionTitleInMessages() {
      if (!state.currentCompletionId) return;
      const taskName = getCurrentCompletionTitle();
      const userName = getUserSpeakerName();
      for (const msgEl of els.chatList.querySelectorAll('.msg')) {
        const id = msgEl.dataset.id;
        if (!id) continue;
        const msg = state.messages.find(m => m && m.id === id);
        if (!msg) continue;
        const left = msgEl.querySelector('.meta-left');
        if (!left) continue;
        left.textContent = msg.role === 'user' ? userName : (msg.role === 'assistant' ? taskName : 'Á≥ªÁªü');
      }
    }

    function openDrawer() {
      els.drawer.classList.add('open');
      els.drawer.setAttribute('aria-hidden', 'false');
      els.backdrop.classList.add('show');
    }

    function closeDrawer() {
      els.drawer.classList.remove('open');
      els.drawer.setAttribute('aria-hidden', 'true');
      els.backdrop.classList.remove('show');
    }

    function setBusyGenerating(isBusy) {
      els.sendBtn.disabled = isBusy;
      els.stopBtn.disabled = !isBusy;
      els.modelSelect.disabled = isBusy;
      els.refreshModels.disabled = isBusy;
      els.streamToggle.disabled = isBusy;
      els.thinkingToggle.disabled = isBusy;
      els.promptInput.disabled = isBusy ? false : false;
    }

    function setCompletionsLoading(isLoading) {
      state.isLoadingCompletions = isLoading;
      els.newSessionBtn.disabled = isLoading;
      els.reloadSessionsBtn.disabled = isLoading;
      els.drawerHint.textContent = isLoading ? 'Âä†ËΩΩ‰∏≠‚Ä¶' : '';
    }

    function maybeScrollToBottom() {
      if (!els.autoScroll.checked) return;
      els.chatList.scrollTop = els.chatList.scrollHeight;
    }

    function findMessageIndexById(id) {
      if (!id) return -1;
      return state.messages.findIndex(m => m && m.id === id);
    }

    function openEditModal(messageId) {
      if (state.abortController) return;
      const idx = findMessageIndexById(messageId);
      if (idx < 0) return;
      const msg = state.messages[idx];
      state.editingMessageId = msg.id;
      els.editTextarea.value = msg.content || '';
      els.editModal.classList.add('show');
      els.editModal.setAttribute('aria-hidden', 'false');
      setTimeout(() => {
        try { els.editTextarea.focus(); } catch (e) { }
      }, 0);
    }

    function closeEditModal() {
      state.editingMessageId = null;
      els.editModal.classList.remove('show');
      els.editModal.setAttribute('aria-hidden', 'true');
    }

    function openKVCacheModal() {
      els.kvCacheModal.classList.add('show');
      els.kvCacheModal.setAttribute('aria-hidden', 'false');
    }

    function closeKVCacheModal() {
      els.kvCacheModal.classList.remove('show');
      els.kvCacheModal.setAttribute('aria-hidden', 'true');
    }

    function saveEditModal() {
      const id = state.editingMessageId;
      if (!id) return;
      const text = (els.editTextarea.value == null ? '' : String(els.editTextarea.value));
      updateMessage(id, text);
      scheduleSave('ÁºñËæëÊ∞îÊ≥°');
      closeEditModal();
    }

    function deleteMessage(messageId) {
      if (state.abortController) return;
      const idx = findMessageIndexById(messageId);
      if (idx < 0) return;
      if (!confirm('Á°ÆËÆ§Âà†Èô§ËØ•Ê∞îÊ≥°ÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ')) return;
      state.messages.splice(idx, 1);
      rerenderAll();
      scheduleSave('Âà†Èô§Ê∞îÊ≥°');
    }


    // Ê∏≤ÊüìËÅäÂ§©Ê∞îÊ≥°
    function renderMessage(msg) {
      const wrap = document.createElement('div');
      wrap.className = 'msg ' + msg.role;
      wrap.dataset.id = msg.id;

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.textContent = msg.role === 'user' ? '‰Ω†' : (msg.role === 'assistant' ? 'AI' : 'SYS');

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const meta = document.createElement('div');
      meta.className = 'meta';
      const left = document.createElement('div');
      left.className = 'meta-left';
      const taskName = getCurrentCompletionTitle();
      const userName = getUserSpeakerName();
      // Âè™ÊòæÁ§∫ÂêçÂ≠ó
      left.textContent = msg.role === 'user' ? userName : (msg.role === 'assistant' ? taskName : 'Á≥ªÁªü');

      const right = document.createElement('div');
      right.className = 'meta-right';

      const timeEl = document.createElement('div');
      timeEl.textContent = msg.ts ? new Date(msg.ts).toLocaleTimeString() : '';

      const actions = document.createElement('div');
      actions.className = 'msg-actions';

      function addAction(label, cls, onClick) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'msg-btn' + (cls ? (' ' + cls) : '');
        b.textContent = label;
        b.addEventListener('click', (e) => {
          e.stopPropagation();
          onClick();
        });
        actions.appendChild(b);
        return b;
      }

      if (msg.role !== 'system') {
        addAction('ÈáçÁîüÊàê', 'ghost', () => regenerateMessage(msg.id));
      }
      addAction('ÁºñËæë', 'ghost', () => openEditModal(msg.id));
      addAction('Âà†Èô§', 'danger', () => deleteMessage(msg.id));

      right.appendChild(timeEl);
      right.appendChild(actions);
      meta.appendChild(left);
      meta.appendChild(right);

      const head = document.createElement('div');
      head.className = 'msg-head';
      head.appendChild(avatar);
      head.appendChild(meta);

      const content = document.createElement('div');
      content.className = 'content';
      renderMessageContentNow(content, msg.content || '');

      let reasoningPre = null;
      const reasoningText = (typeof msg.reasoning === 'string' ? msg.reasoning : '');
      if (msg.role === 'assistant' && reasoningText.trim()) {
        const details = document.createElement('details');
        details.className = 'reasoning';
        const summary = document.createElement('summary');
        summary.textContent = 'ÊÄùËÄÉËøáÁ®ã';
        reasoningPre = document.createElement('pre');
        reasoningPre.textContent = reasoningText;
        details.appendChild(summary);
        details.appendChild(reasoningPre);
        bubble.appendChild(details);
      }

      bubble.appendChild(content);
      const attachmentsEl = document.createElement('div');
      attachmentsEl.className = 'attachments';
      bubble.appendChild(attachmentsEl);
      renderMessageAttachments(attachmentsEl, msg);

      wrap.appendChild(head);
      wrap.appendChild(bubble);

      state.messageEls.set(msg.id, { contentEl: content, reasoningEl: reasoningPre, attachmentsEl });
      els.chatList.appendChild(wrap);
      maybeScrollToBottom();
    }

    function clearChatDom() {
      els.chatList.innerHTML = '';
      state.messageEls.clear();
    }

    function rerenderAll() {
      clearChatDom();
      for (const m of state.messages) renderMessage(m);
      maybeScrollToBottom();
    }

    function addMessage(role, content) {
      const msg = { id: uid(), role, content: content || '', ts: Date.now() };
      state.messages.push(msg);
      renderMessage(msg);
      return msg;
    }

    function updateMessage(id, content) {
      const entry = state.messageEls.get(id);
      const el = entry && entry.contentEl ? entry.contentEl : entry;
      if (el) requestRenderMessageContent(el, content || '');
      const m = state.messages.find(x => x.id === id);
      if (m) m.content = content || '';
      maybeScrollToBottom();
    }

    function updateAttachments(id) {
      const m = state.messages.find(x => x.id === id);
      if (!m) return;
      const entry = state.messageEls.get(id);
      let attachmentsEl = entry && entry.attachmentsEl ? entry.attachmentsEl : null;
      if (!attachmentsEl) {
        const wrap = els.chatList.querySelector('.msg[data-id="' + id + '"]');
        const bubble = wrap ? wrap.querySelector('.bubble') : null;
        attachmentsEl = bubble ? bubble.querySelector('.attachments') : null;
      }
      if (!attachmentsEl) return;
      renderMessageAttachments(attachmentsEl, m);
      if (entry) {
        state.messageEls.set(id, { contentEl: entry.contentEl, reasoningEl: entry.reasoningEl, attachmentsEl });
      }
      maybeScrollToBottom();
    }

    function updateReasoning(id, reasoning) {
      const entry = state.messageEls.get(id);
      const pre = entry && entry.reasoningEl ? entry.reasoningEl : null;
      const reasoningText = (reasoning == null ? '' : String(reasoning));
      if (pre) {
        pre.textContent = reasoningText;
      } else if (reasoningText.trim()) {
        const wrap = els.chatList.querySelector('.msg.assistant[data-id="' + id + '"]');
        const bubble = wrap ? wrap.querySelector('.bubble') : null;
        if (bubble) {
          const details = document.createElement('details');
          details.className = 'reasoning';
          const summary = document.createElement('summary');
          summary.textContent = 'ÊÄùËÄÉËøáÁ®ã';
          const newPre = document.createElement('pre');
          newPre.textContent = reasoningText;
          details.appendChild(summary);
          details.appendChild(newPre);
          bubble.insertBefore(details, bubble.firstChild);
          state.messageEls.set(id, { contentEl: entry && entry.contentEl ? entry.contentEl : bubble.querySelector('.content'), reasoningEl: newPre, attachmentsEl: entry && entry.attachmentsEl ? entry.attachmentsEl : bubble.querySelector('.attachments') });
        }
      }
      const m = state.messages.find(x => x.id === id);
      if (m) m.reasoning = reasoningText;
      maybeScrollToBottom();
    }

    // ËøôÈáåÁîüÊàêÂèëÈÄÅÁöÑÊ∂àÊÅØ
    // ÊûÑÈÄ†/v1/completionsÁî®ÁöÑÊ∂àÊÅØ„ÄÇ
    function buildPrompt(messages) {
      const lines = [];
      const sys = (els.systemPrompt.value || '').trim();
      if (sys) lines.push('System: ' + sys);
      //const role = (els.rolePrompt.value || '').trim();
      //if (role) lines.push('System: ËßíËâ≤ËÆæÂÆöÔºö' + role);
      // ÊèíÂÖ•Êç¢Ë°åÁ¨¶Ôºå‰∏çÂæóÂà†Èô§
      lines.push('***');
      const userName = getUserSpeakerName();
      const assistantName = getAssistantSpeakerName();
      const userPrefix = getUserMessagePrefix();
      const userSuffix = getUserMessageSuffix();
      const assistantPrefix = getAssistantMessagePrefix();
      const assistantSuffix = getAssistantMessageSuffix();
      const history = Array.isArray(messages) ? messages : state.messages;
      for (const m of (Array.isArray(history) ? history : [])) {
        if (m.role === 'system') {
          lines.push('System: ' + (m.content || ''));
        } else if (m.role === 'user') {
          let t = (m.content || '');
          const atts = Array.isArray(m.attachments) ? m.attachments : [];
          for (const a of atts) {
            if (a && a.url) {
              t += (t ? '\n' : '') + '[file] ' + String(a.url);
            }
          }
          lines.push(userName + ': ' + userPrefix + t + userSuffix);
        } else if (m.role === 'assistant') {
          lines.push(assistantName + ': ' + assistantPrefix + (m.content || '') + assistantSuffix);
        }
      }
      lines.push(assistantName + ': ' + assistantPrefix);
      return lines.join('\n');
    }


    // Áªô/v1/chat/completionsÁ´ØÁÇπÊûÑÈÄ†ËØ∑Ê±ÇÂÜÖÂÆπ
    function buildContent(messages) {
      const history = Array.isArray(messages) ? messages : state.messages;
      const out = [];
      const sys = (els.systemPrompt.value || '').trim();
      const rolePrompt = (els.rolePrompt.value || '').trim();

      if (sys) out.push({ role: 'system', content: sys });
      if (rolePrompt) out.push({ role: 'system', content: rolePrompt });
      // ÂèÇËÄÉÈÖíÈ¶ÜÁöÑÊèêÁ§∫ËØç
      out.push({ role: 'system', content: '[Start a new Chat]' });

      const userPrefix = getUserMessagePrefix();
      const userSuffix = getUserMessageSuffix();
      // ÂÆûÈôÖ‰∏äÔºåËøô‰∏™‰∏úË•øÂ∞±‰∏çÁîüÊïà‰∫ÜÔºå‰∏çËøáÂÖàÊãºÂú®ÈáåÈù¢ÁúãÁúãÂêß
      const assistantPrefix = getAssistantMessagePrefix();
      const assistantSuffix = getAssistantMessageSuffix();
      // ÈÅçÂéÜÂÖ®ÈÉ®ÁöÑÂéÜÂè≤Ê∂àÊÅØÔºåÊãºÊé•‰∏∫messages
      for (const m of (Array.isArray(history) ? history : [])) {
        const role = m?.role;
        if (role !== 'system' && role !== 'user' && role !== 'assistant') continue;
        const raw = (m?.content == null ? '' : String(m.content));
        if (role === 'system') {
          out.push({ role: 'system', content: raw });
        } else if (role === 'user') {
          if (userPrefix != null && userPrefix.length != 0)
            out.push({ role: 'user', content: userPrefix });
          const atts = Array.isArray(m?.attachments) ? m.attachments : [];
          if (atts.length > 0) {
            const parts = [];
            if (raw && raw.length) parts.push({ type: 'text', text: raw });
            for (const a of atts) {
              if (!a || !a.url) continue;
              parts.push({ type: 'file', text: String(a.url) });
            }
            out.push({ role: 'user', content: parts.length ? parts : raw });
          } else {
            out.push({ role: 'user', content: raw });
          }
          if (userSuffix != null && userSuffix.length != 0)
            out.push({ role: 'user', content: userSuffix });
        } else if (role === 'assistant') {
          if(raw && raw.trim().length > 0) {
            if(assistantPrefix != null && assistantPrefix.length != 0)
              out.push({ role: 'assistant', content: assistantPrefix });
            out.push({ role: 'assistant', content: raw });
            if(assistantSuffix != null && assistantSuffix.length != 0)
              out.push({ role: 'assistant', content: assistantSuffix });
          }
        }
      }
      return out;
    }

    function extractDeltaParts(json) {
      const c0 = json?.choices?.[0];
      if (!c0) return { content: '', reasoning: '' };
      let content = '';
      let reasoning = '';
      if (typeof c0.text === 'string') content = c0.text;
      if (typeof c0.delta?.content === 'string') content = c0.delta.content;
      if (typeof c0.message?.content === 'string') content = c0.message.content;
      if (typeof c0.delta?.reasoning_content === 'string') reasoning = c0.delta.reasoning_content;
      if (typeof c0.message?.reasoning_content === 'string') reasoning = c0.message.reasoning_content;
      if (typeof c0.reasoning_content === 'string') reasoning = c0.reasoning_content;
      if (typeof json?.reasoning_content === 'string') reasoning = json.reasoning_content;
      return { content, reasoning };
    }

    async function consumeSseStream(res, assistantMsgId) {
      const reader = res.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let text = '';
      let reasoning = '';
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split(/\r?\n/);
        buffer = lines.pop() || '';
        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          const data = line.slice(6).trim();
          if (data === '[DONE]') {
            updateMessage(assistantMsgId, text);
            if (reasoning) updateReasoning(assistantMsgId, reasoning);
            return;
          }
          try {
            const json = JSON.parse(data);
            const parts = extractDeltaParts(json);
            if (parts.reasoning) {
              reasoning += parts.reasoning;
              updateReasoning(assistantMsgId, reasoning);
            }
            if (parts.content) {
              text += parts.content;
              updateMessage(assistantMsgId, text);
            }
          } catch (e) { }
        }
      }
      updateMessage(assistantMsgId, text);
      if (reasoning) updateReasoning(assistantMsgId, reasoning);
    }

    function currentParams() {
      const rawMinP = String(els.minP.value || '').trim();
      const rawRepeatPenalty = String(els.repeatPenalty.value || '').trim();
      const stopLines = String(els.stopSequences.value || '')
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean);

      const min_p = rawMinP ? Number(rawMinP) : undefined;
      const repeat_penalty = rawRepeatPenalty ? Number(rawRepeatPenalty) : undefined;
      const stop = stopLines.length ? stopLines : undefined;

      return {
        max_tokens: Number(els.maxTokens.value || 1024),
        temperature: Number(els.temperature.value || 0.7),
        top_p: Number(els.topP.value || 1),
        min_p: (Number.isFinite(min_p) ? min_p : undefined),
        repeat_penalty: (Number.isFinite(repeat_penalty) ? repeat_penalty : undefined),
        stop
      };
    }

    async function generateIntoMessage(contextMessages, assistantMsgId) {
      const model = els.modelSelect.value || '';
      const params = currentParams();
      state.abortController = new AbortController();
      setStatus('ÁîüÊàê‰∏≠‚Ä¶');
      setBusyGenerating(true);
      setSaveHint('');

      try {
        await maybeUploadPendingAttachment();
        const isChat = state.apiModel === 1;
        const useStream = !!els.streamToggle.checked;
        const url = isChat ? '/v1/chat/completions' : '/v1/completions';
        const stop = (params.stop != null
          ? params.stop
          : (isChat ? ["<|endoftext|>"] : ['\n' + getUserSpeakerName(), '\n***']));
        const body = isChat
          ? {
            model,
            messages: buildContent(contextMessages),
            max_tokens: params.max_tokens,
            temperature: params.temperature,
            top_p: params.top_p,
            min_p: params.min_p,
            repeat_penalty: params.repeat_penalty,
            enable_thinking: !!els.thinkingToggle.checked,
            stream: useStream, 
            stop
          }
          : {
            model,
            prompt: buildPrompt(contextMessages),
            max_tokens: params.max_tokens,
            temperature: params.temperature,
            top_p: params.top_p,
            min_p: params.min_p,
            repeat_penalty: params.repeat_penalty,
            enable_thinking: !!els.thinkingToggle.checked,
            stream: useStream,
            stop
          };

        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
          signal: state.abortController.signal
        });

        if (!res.ok) {
          const t = await res.text();
          let msg = t;
          try {
            const j = t ? JSON.parse(t) : null;
            msg = j?.message || j?.error?.message || t;
          } catch (e) { }
          throw new Error(msg || ('HTTP ' + res.status));
        }

        const ct = (res.headers.get('content-type') || '').toLowerCase();
        if (ct.includes('text/event-stream')) {
          await consumeSseStream(res, assistantMsgId);
        } else {
          const data = await res.json();
          const parts = extractDeltaParts(data);
          updateMessage(assistantMsgId, parts.content || '');
          if (parts.reasoning) updateReasoning(assistantMsgId, parts.reasoning);
        }

        scheduleSave('ÂÆåÊàê');
      } catch (e) {
        if (e.name === 'AbortError') {
          setStatus('Â∑≤ÂÅúÊ≠¢');
          scheduleSave('ÂÅúÊ≠¢');
        } else {
          setStatus('ÁîüÊàêÂ§±Ë¥•Ôºö' + e.message);
          addMessage('system', 'ÁîüÊàêÂ§±Ë¥•Ôºö' + e.message);
          scheduleSave('Â§±Ë¥•');
        }
      } finally {
        setBusyGenerating(false);
        state.abortController = null;
      }
    }

    async function regenerateMessage(messageId) {
      if (state.abortController) return;
      const idx = findMessageIndexById(messageId);
      if (idx < 0) return;
      const msg = state.messages[idx];
      if (msg.role === 'system') return;

      const hasLater = idx < state.messages.length - 1;
      if (hasLater) {
        if (!confirm('Â∞ÜÂà†Èô§ËØ•Ê∞îÊ≥°‰πãÂêéÁöÑÂØπËØùÂÜÖÂÆπÂπ∂‰ªéËøôÈáåÈáçÊñ∞ÁîüÊàêÔºåÁªßÁª≠Ôºü')) return;
      }

      if (msg.role === 'assistant') {
        state.messages = state.messages.slice(0, idx + 1);
        rerenderAll();
        updateMessage(msg.id, '');
        scheduleSave('ÈáçÁîüÊàê');
        await generateIntoMessage(state.messages.slice(0, idx), msg.id);
        return;
      }

      if (msg.role === 'user') {
        state.messages = state.messages.slice(0, idx + 1);
        rerenderAll();
        const assistantMsg = addMessage('assistant', '');
        scheduleSave('ÈáçÁîüÊàê');
        await generateIntoMessage(state.messages, assistantMsg.id);
      }
    }

    // Ëøô‰∏™ÂäüËÉΩ‰∏çÂÜç‰ΩøÁî®
    function scheduleSave(reason) {
      if (!state.currentCompletionId) return;
      if (state.saveTimer) clearTimeout(state.saveTimer);
      state.saveTimer = setTimeout(() => saveCompletion(reason).catch(() => { }), 450);
    }

    function buildParamsJson() {
      return JSON.stringify({
        model: els.modelSelect.value || '',
        apiModel: state.apiModel,
        userName: (els.userName.value || '').trim(),
        userPrefix: (els.userPrefix.value == null ? '' : String(els.userPrefix.value)),
        userSuffix: (els.userSuffix.value == null ? '' : String(els.userSuffix.value)),
        assistantPrefix: (els.assistantPrefix.value == null ? '' : String(els.assistantPrefix.value)),
        assistantSuffix: (els.assistantSuffix.value == null ? '' : String(els.assistantSuffix.value)),
        enableThinking: !!els.thinkingToggle.checked,
        params: currentParams(),
        history: state.messages
      });
    }

    async function saveCompletion(reason) {
      if (!state.currentCompletionId) return;
      const payload = {
        id: Number(state.currentCompletionId),
        title: els.titleInput.value || '',
        prompt: lzCompressIfNeeded(els.rolePrompt.value || ''),
        systemPrompt: lzCompressIfNeeded(els.systemPrompt.value || ''),
        paramsJson: lzCompressIfNeeded(buildParamsJson()),
        apiModel: state.apiModel,
        createdAt: Number(state.currentCreatedAt || 0),
        updatedAt: Date.now()
      };
      setSaveHint('‰øùÂ≠ò‰∏≠‚Ä¶');
      await fetchJson('/api/chat/completion/save?name=' + encodeURIComponent(state.currentCompletionId), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      state.lastSavedAt = Date.now();
      setSaveHint((reason ? ('Â∑≤‰øùÂ≠òÔºà' + reason + 'Ôºâ') : 'Â∑≤‰øùÂ≠ò') + ' ¬∑ ' + new Date(state.lastSavedAt).toLocaleTimeString());
      await loadCompletions(false);
    }

    async function loadModels() {
      if (state.isLoadingModels) return;
      state.isLoadingModels = true;
      try {
        setStatus('Âä†ËΩΩÊ®°Âûã‚Ä¶');
        els.refreshModels.disabled = true;
        const data = await fetchJson('/v1/models', { method: 'GET' });
        const models = Array.isArray(data?.data) ? data.data : [];
        const current = els.modelSelect.value;
        els.modelSelect.innerHTML = '';
        if (models.length === 0) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Êú™ÂèëÁé∞Â∑≤Âä†ËΩΩÊ®°Âûã';
          els.modelSelect.appendChild(opt);
          els.modelSelect.disabled = true;
        } else {
          els.modelSelect.disabled = false;
          for (const m of models) {
            const opt = document.createElement('option');
            opt.value = m.id;
            opt.textContent = m.id;
            els.modelSelect.appendChild(opt);
          }
          if (current && models.some(m => m.id === current)) {
            els.modelSelect.value = current;
          }
        }
        setStatus('Â∞±Áª™');
      } catch (e) {
        setStatus('Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•Ôºö' + e.message);
      } finally {
        state.isLoadingModels = false;
        els.refreshModels.disabled = false;
      }
    }

    function renderCompletions(items, currentId) {
      if (!Array.isArray(items)) items = [];
      els.sessionsList.innerHTML = '';
      if (items.length === 0) {
        const li = document.createElement('li');
        li.className = 'session-item';
        li.innerHTML = '<div class="session-meta"><div class="session-title">ÊöÇÊó†ËßíËâ≤</div><div class="session-sub">ÁÇπÂáª‚ÄúÊñ∞Âª∫ËßíËâ≤‚ÄùÂàõÂª∫ËßíËâ≤</div></div>';
        li.style.cursor = 'default';
        els.sessionsList.appendChild(li);
        return;
      }
      for (const s of items) {
        const li = document.createElement('li');
        const id = s?.id == null ? '' : String(s.id);
        li.className = 'session-item' + (id && id === String(currentId || '') ? ' active' : '');
        li.dataset.id = id;
        const title = s?.title || ('ËßíËâ≤ ' + id);
        const sub = (s?.updatedAt ? ('Êõ¥Êñ∞Ôºö' + formatTime(s.updatedAt)) : (s?.createdAt ? ('ÂàõÂª∫Ôºö' + formatTime(s.createdAt)) : ''));
        li.innerHTML = `
          <div class="session-meta">
            <div class="session-title"></div>
            <div class="session-sub"></div>
          </div>
          <button class="btn icon-btn danger" type="button" data-action="delete" title="Âà†Èô§">√ó</button>
        `;
        li.querySelector('.session-title').textContent = title;
        li.querySelector('.session-sub').textContent = sub;
        els.sessionsList.appendChild(li);
      }
    }

    async function loadCompletions(ensureCurrent) {
      setCompletionsLoading(true);
      try {
        const data = await fetchJson('/api/chat/completion/list', { method: 'GET' });
        const items = Array.isArray(data?.data) ? data.data : [];
        let current = state.currentCompletionId;
        if (!current && items[0]?.id != null) current = String(items[0].id);
        renderCompletions(items, current);
        if (ensureCurrent) {
          if (!current) {
            await createCompletion();
            return;
          }
          state.currentCompletionId = String(current);
          await loadCompletion(current);
        }
      } catch (e) {
        els.sessionsList.innerHTML = '';
        const li = document.createElement('li');
        li.className = 'session-item';
        li.innerHTML = '<div class="session-meta"><div class="session-title">Âä†ËΩΩÂ§±Ë¥•</div><div class="session-sub"></div></div>';
        li.querySelector('.session-sub').textContent = e.message;
        li.style.cursor = 'default';
        els.sessionsList.appendChild(li);
      } finally {
        setCompletionsLoading(false);
      }
    }

    async function createCompletion() {
      setCompletionsLoading(true);
      try {
        //const seedTitle = (els.titleInput.value || '').trim().slice(0, 60);
        // ÊîπÁî®ÈªòËÆ§ÁöÑÂêçÂ≠ó
        const seedTitle = 'ÈªòËÆ§ËßíËâ≤-' + Date.now();
        const data = await fetchJson('/api/chat/completion/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: seedTitle })
        });
        const created = data?.data || {};
        if (created.id == null) throw new Error('Êñ∞Âª∫Â§±Ë¥•ÔºöÁº∫Â∞ëËßíËâ≤ID');
        state.currentCompletionId = String(created.id);
        state.currentCreatedAt = Number(created.createdAt || 0);
        await loadCompletions(false);
        await loadCompletion(state.currentCompletionId);
      } catch (e) {
        els.drawerHint.textContent = 'Êñ∞Âª∫Â§±Ë¥•Ôºö' + e.message;
      } finally {
        setCompletionsLoading(false);
      }
    }

    async function deleteCompletion(id) {
      if (!id) return;
      if (!confirm('Á°ÆËÆ§Âà†Èô§ËØ•ËßíËâ≤ÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ')) return;
      setCompletionsLoading(true);
      try {
        await fetchJson('/api/chat/completion/delete?name=' + encodeURIComponent(id), { method: 'DELETE' });
        if (String(id) === String(state.currentCompletionId || '')) {
          state.currentCompletionId = null;
          state.currentCreatedAt = 0;
        }
        await loadCompletions(false);
        if (state.currentCompletionId) {
          await loadCompletion(state.currentCompletionId);
        } else {
          els.titleInput.value = '';
          els.systemPrompt.value = '';
          els.rolePrompt.value = '';
          state.messages = [];
          rerenderAll();
        }
      } catch (e) {
        els.drawerHint.textContent = 'Âà†Èô§Â§±Ë¥•Ôºö' + e.message;
      } finally {
        setCompletionsLoading(false);
      }
    }

    async function switchCompletion(id) {
      if (!id) return;
      if (String(id) === String(state.currentCompletionId || '')) return;
      setCompletionsLoading(true);
      try {
        state.currentCompletionId = String(id);
        await loadCompletions(false);
        await loadCompletion(state.currentCompletionId);
        closeDrawer();
      } catch (e) {
        els.drawerHint.textContent = 'ÂàáÊç¢Â§±Ë¥•Ôºö' + e.message;
      } finally {
        setCompletionsLoading(false);
      }
    }

    function normalizeHistory(history) {
      if (!Array.isArray(history)) return [];
      const out = [];
      for (const m of history) {
        const role = m?.role;
        if (role !== 'user' && role !== 'assistant' && role !== 'system') continue;
        const attachments = Array.isArray(m?.attachments)
          ? m.attachments
            .filter(a => a && typeof a.url === 'string' && a.url.trim() && (a.type === 'file' || a.type === 'image_url' || a.type === 'text_file' || a.type === 'file_url'))
            .map(a => {
              const t = String(a.type);
              if (t === 'file') {
                return { type: 'file', url: String(a.url), name: (a.name == null ? '' : String(a.name)), isImage: a.isImage === true };
              }
              if (t === 'image_url') {
                return { type: 'file', url: String(a.url), name: (a.name == null ? '' : String(a.name)), isImage: true };
              }
              return { type: 'file', url: String(a.url), name: (a.name == null ? '' : String(a.name)), isImage: false };
            })
          : [];
        out.push({
          id: m?.id || uid(),
          role,
          content: (m?.content == null ? '' : String(m.content)),
          attachments,
          reasoning: (typeof m?.reasoning === 'string' ? m.reasoning : ''),
          ts: typeof m?.ts === 'number' ? m.ts : Date.now()
        });
      }
      return out;
    }

    async function loadCompletion(id) {
      const data = await fetchJson('/api/chat/completion/get?name=' + encodeURIComponent(id), { method: 'GET' });
      const s = data?.data || {};
      els.titleInput.value = s.title || '';
      els.systemPrompt.value = lzDecompressIfNeeded(s.systemPrompt || '');
      els.rolePrompt.value = lzDecompressIfNeeded(s.prompt || '');
      state.currentCreatedAt = Number(s.createdAt || 0);

      let ext = {};
      const paramsJsonText = lzDecompressIfNeeded(s.paramsJson || '');
      try { ext = paramsJsonText ? JSON.parse(paramsJsonText) : {}; } catch (e) { ext = {}; }
      if (ext?.model) els.modelSelect.value = ext.model;
      els.userName.value = (ext?.userName == null ? '' : String(ext.userName));
      els.userPrefix.value = (ext?.userPrefix == null ? '' : String(ext.userPrefix));
      els.userSuffix.value = (ext?.userSuffix == null ? '' : String(ext.userSuffix));
      els.assistantPrefix.value = (ext?.assistantPrefix == null ? '' : String(ext.assistantPrefix));
      els.assistantSuffix.value = (ext?.assistantSuffix == null ? '' : String(ext.assistantSuffix));
      if (ext?.params?.max_tokens != null) els.maxTokens.value = String(ext.params.max_tokens);
      if (ext?.params?.temperature != null) els.temperature.value = String(ext.params.temperature);
      if (ext?.params?.top_p != null) els.topP.value = String(ext.params.top_p);
      els.minP.value = '';
      els.repeatPenalty.value = '';
      els.stopSequences.value = '';
      if (ext?.params?.min_p != null) els.minP.value = String(ext.params.min_p);
      if (ext?.params?.repeat_penalty != null) els.repeatPenalty.value = String(ext.params.repeat_penalty);
      const stopVal = ext?.params?.stop;
      if (Array.isArray(stopVal)) els.stopSequences.value = stopVal.map(s => String(s)).join('\n');
      else if (typeof stopVal === 'string') els.stopSequences.value = stopVal;
      if (ext?.enableThinking != null) els.thinkingToggle.checked = !!ext.enableThinking;
      else els.thinkingToggle.checked = true;

      const loadedApiModel = (ext?.apiModel != null ? ext.apiModel : s.apiModel);
      if (loadedApiModel != null) {
        state.apiModel = Number(loadedApiModel) === 0 ? 0 : 1;
      }
      els.apiModelSelect.value = String(state.apiModel);

      state.messages = normalizeHistory(ext?.history);
      rerenderAll();
      setSaveHint('');
    }

    async function runCompletion() {
      const userText = (els.promptInput.value || '').trim();
      if (!userText) {
        setStatus('ËØ∑ËæìÂÖ•Ê∂àÊÅØ');
        return;
      }
      if (!state.currentCompletionId) {
        await loadCompletions(true);
        if (!state.currentCompletionId) return;
      }

      els.promptInput.value = '';
      const userMsg = addMessage('user', userText);
      if (state.pendingAttachment && state.pendingAttachment.file) {
        state.pendingAttachment.messageId = userMsg.id;
      }
      const assistantMsg = addMessage('assistant', '');
      scheduleSave('ÂèëÈÄÅ');
      await generateIntoMessage(state.messages, assistantMsg.id);
    }

    async function saveKVCache() {
      try {
        const modelId = els.modelSelect.value;
        if (!modelId) {
          setStatus('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã');
          return;
        }

        // ÈªòËÆ§‰ΩøÁî®slot 0
        const slotId = 0;

        setStatus('‰øùÂ≠òKVÁºìÂ≠ò‰∏≠...');
        const response = await fetchJson('/api/models/slots/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modelId: modelId,
            slotId: slotId
          })
        });

        if (response.success) {
          setStatus('KVÁºìÂ≠ò‰øùÂ≠òÊàêÂäü');
        } else {
          setStatus('KVÁºìÂ≠ò‰øùÂ≠òÂ§±Ë¥•: ' + (response.message || 'Êú™Áü•ÈîôËØØ'));
        }
      } catch (e) {
        setStatus('KVÁºìÂ≠ò‰øùÂ≠òÂ§±Ë¥•: ' + e.message);
      }
    }

    async function loadKVCache() {
      try {
        const modelId = els.modelSelect.value;
        if (!modelId) {
          setStatus('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã');
          return;
        }

        // ÈªòËÆ§‰ΩøÁî®slot 0
        const slotId = 0;

        setStatus('Âä†ËΩΩKVÁºìÂ≠ò‰∏≠...');
        const response = await fetchJson('/api/models/slots/load', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modelId: modelId,
            slotId: slotId
          })
        });

        if (response.success) {
          setStatus('KVÁºìÂ≠òÂä†ËΩΩÊàêÂäü');
        } else {
          setStatus('KVÁºìÂ≠òÂä†ËΩΩÂ§±Ë¥•: ' + (response.message || 'Êú™Áü•ÈîôËØØ'));
        }
      } catch (e) {
        setStatus('KVÁºìÂ≠òÂä†ËΩΩÂ§±Ë¥•: ' + e.message);
      }
    }

    function bindEvents() {
      els.sessionsToggle.addEventListener('click', () => {
        openDrawer();
        loadCompletions(false);
      });
      els.drawerClose.addEventListener('click', closeDrawer);
      els.backdrop.addEventListener('click', closeDrawer);

      els.modelRowToggle.addEventListener('click', () => {
        const open = els.modelRow.classList.toggle('visible');
        els.modelRowToggle.textContent = open ? '√ó' : '‚ò∞';
        els.modelRowToggle.title = open ? 'ÈöêËóèÊ®°ÂûãÊ†è' : 'ÊòæÁ§∫Ê®°ÂûãÊ†è';
        els.modelRowToggle.setAttribute('aria-label', open ? 'ÈöêËóèÊ®°ÂûãÊ†è' : 'ÊòæÁ§∫Ê®°ÂûãÊ†è');
        els.modelRowToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      });

      els.refreshModels.addEventListener('click', () => loadModels());

      els.attachBtn.addEventListener('click', () => {
        if (els.attachInput) els.attachInput.click();
      });
      els.attachInput.addEventListener('change', (e) => {
        const file = e && e.target && e.target.files ? e.target.files[0] : null;
        setAttachment(file);
      });
      els.attachClear.addEventListener('click', () => clearAttachment());

      els.sendBtn.addEventListener('click', () => runCompletion());
      els.stopBtn.addEventListener('click', () => {
        if (state.abortController) state.abortController.abort();
      });

      els.clearChat.addEventListener('click', () => {
        if (!confirm('Á°ÆËÆ§Ê∏ÖÁ©∫ÂΩìÂâçËßíËâ≤ÁöÑÂØπËØùÂÜÖÂÆπÔºü')) return;
        state.messages = [];
        rerenderAll();
        scheduleSave('Ê∏ÖÁ©∫ÂØπËØù');
      });

      els.toggleSettings.addEventListener('click', () => {
        const open = els.settingsPanel.classList.toggle('open');
        els.sysPromptBox.classList.toggle('open', open);
        els.rolePromptBox.classList.toggle('open', open);
        document.documentElement.style.overflow = open ? 'hidden' : '';
      });
      els.closeSettings.addEventListener('click', () => {
        els.settingsPanel.classList.remove('open');
        els.sysPromptBox.classList.remove('open');
        els.rolePromptBox.classList.remove('open');
        document.documentElement.style.overflow = '';
      });

      els.newSessionBtn.addEventListener('click', () => createCompletion());
      els.reloadSessionsBtn.addEventListener('click', () => loadCompletions(false));

      els.sessionsList.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action="delete"]');
        const item = e.target.closest('.session-item');
        const id = item?.dataset?.id;
        if (btn && id) {
          e.stopPropagation();
          deleteCompletion(id);
          return;
        }
        if (id) switchCompletion(id);
      });

      els.titleInput.addEventListener('input', () => {
        refreshCompletionTitleInMessages();
        scheduleSave('Ê†áÈ¢ò');
      });
      els.modelSelect.addEventListener('change', () => scheduleSave('Ê®°Âûã'));
      els.apiModelSelect.addEventListener('change', () => {
        state.apiModel = Number(els.apiModelSelect.value) === 0 ? 0 : 1;
        scheduleSave('Á´ØÁÇπ');
      });
      els.systemPrompt.addEventListener('input', () => scheduleSave('Á≥ªÁªüÊèèËø∞'));
      els.rolePrompt.addEventListener('input', () => scheduleSave('ËßíËâ≤ËÆæÂÆö'));
      els.userName.addEventListener('input', () => scheduleSave('Áî®Êà∑Âêç'));
      els.userPrefix.addEventListener('input', () => scheduleSave('Áî®Êà∑ÂâçÁºÄ'));
      els.userSuffix.addEventListener('input', () => scheduleSave('Áî®Êà∑ÂêéÁºÄ'));
      els.assistantPrefix.addEventListener('input', () => scheduleSave('Âä©ÊâãÂâçÁºÄ'));
      els.assistantSuffix.addEventListener('input', () => scheduleSave('Âä©ÊâãÂêéÁºÄ'));
      els.maxTokens.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.temperature.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.topP.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.minP.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.repeatPenalty.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.stopSequences.addEventListener('input', () => scheduleSave('ÂèÇÊï∞'));
      els.thinkingToggle.addEventListener('change', () => scheduleSave('ÊÄùËÄÉÂºÄÂÖ≥'));

      // KVÁºìÂ≠òÊåâÈíÆ‰∫ã‰ª∂
      els.kvCacheToggle.addEventListener('click', openKVCacheModal);
      els.kvCacheClose.addEventListener('click', closeKVCacheModal);
      els.kvCacheCancel.addEventListener('click', closeKVCacheModal);
      els.kvCacheModal.addEventListener('click', (e) => {
        if (e.target === els.kvCacheModal) closeKVCacheModal();
      });
      els.saveKV.addEventListener('click', saveKVCache);
      els.loadKV.addEventListener('click', loadKVCache);

      els.editModal.addEventListener('click', (e) => {
        if (e.target === els.editModal) return;
      });
      els.editClose.addEventListener('click', closeEditModal);
      els.editCancel.addEventListener('click', closeEditModal);
      els.editSave.addEventListener('click', saveEditModal);

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (els.editModal.classList.contains('show')) {
            closeEditModal();
            return;
          }
          if (els.kvCacheModal.classList.contains('show')) {
            closeKVCacheModal();
            return;
          }
          if (els.settingsPanel.classList.contains('open')) {
            els.settingsPanel.classList.remove('open');
            els.sysPromptBox.classList.remove('open');
            els.rolePromptBox.classList.remove('open');
            document.documentElement.style.overflow = '';
            return;
          }
          if (els.drawer.classList.contains('open')) {
            closeDrawer();
            return;
          }
        }
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          if (els.editModal.classList.contains('show')) {
            saveEditModal();
            return;
          }
          runCompletion();
        }
      });
    }

    // ÂïìÂãïÂêéÂ∞±Âü∑Ë°åÂàùÂßãÂåñ
    async function init() {
      bindEvents();
      renderAttachment();
      els.apiModelSelect.value = String(state.apiModel);
      await loadModels();
      await loadCompletions(true);
    }

    init();
  </script>
</body>

</html>
